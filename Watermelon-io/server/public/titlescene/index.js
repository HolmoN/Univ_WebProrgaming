/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/engine.io-client/node_modules/debug/src/browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/engine.io-client/node_modules/debug/src/browser.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */\r\n\r\n/**\r\n * This is the web browser implementation of `debug()`.\r\n */\r\n\r\nexports.formatArgs = formatArgs;\r\nexports.save = save;\r\nexports.load = load;\r\nexports.useColors = useColors;\r\nexports.storage = localstorage();\r\nexports.destroy = (() => {\r\n\tlet warned = false;\r\n\r\n\treturn () => {\r\n\t\tif (!warned) {\r\n\t\t\twarned = true;\r\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\r\n\t\t}\r\n\t};\r\n})();\r\n\r\n/**\r\n * Colors.\r\n */\r\n\r\nexports.colors = [\r\n\t'#0000CC',\r\n\t'#0000FF',\r\n\t'#0033CC',\r\n\t'#0033FF',\r\n\t'#0066CC',\r\n\t'#0066FF',\r\n\t'#0099CC',\r\n\t'#0099FF',\r\n\t'#00CC00',\r\n\t'#00CC33',\r\n\t'#00CC66',\r\n\t'#00CC99',\r\n\t'#00CCCC',\r\n\t'#00CCFF',\r\n\t'#3300CC',\r\n\t'#3300FF',\r\n\t'#3333CC',\r\n\t'#3333FF',\r\n\t'#3366CC',\r\n\t'#3366FF',\r\n\t'#3399CC',\r\n\t'#3399FF',\r\n\t'#33CC00',\r\n\t'#33CC33',\r\n\t'#33CC66',\r\n\t'#33CC99',\r\n\t'#33CCCC',\r\n\t'#33CCFF',\r\n\t'#6600CC',\r\n\t'#6600FF',\r\n\t'#6633CC',\r\n\t'#6633FF',\r\n\t'#66CC00',\r\n\t'#66CC33',\r\n\t'#9900CC',\r\n\t'#9900FF',\r\n\t'#9933CC',\r\n\t'#9933FF',\r\n\t'#99CC00',\r\n\t'#99CC33',\r\n\t'#CC0000',\r\n\t'#CC0033',\r\n\t'#CC0066',\r\n\t'#CC0099',\r\n\t'#CC00CC',\r\n\t'#CC00FF',\r\n\t'#CC3300',\r\n\t'#CC3333',\r\n\t'#CC3366',\r\n\t'#CC3399',\r\n\t'#CC33CC',\r\n\t'#CC33FF',\r\n\t'#CC6600',\r\n\t'#CC6633',\r\n\t'#CC9900',\r\n\t'#CC9933',\r\n\t'#CCCC00',\r\n\t'#CCCC33',\r\n\t'#FF0000',\r\n\t'#FF0033',\r\n\t'#FF0066',\r\n\t'#FF0099',\r\n\t'#FF00CC',\r\n\t'#FF00FF',\r\n\t'#FF3300',\r\n\t'#FF3333',\r\n\t'#FF3366',\r\n\t'#FF3399',\r\n\t'#FF33CC',\r\n\t'#FF33FF',\r\n\t'#FF6600',\r\n\t'#FF6633',\r\n\t'#FF9900',\r\n\t'#FF9933',\r\n\t'#FFCC00',\r\n\t'#FFCC33'\r\n];\r\n\r\n/**\r\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\r\n * and the Firebug extension (any Firefox version) are known\r\n * to support \"%c\" CSS customizations.\r\n *\r\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\r\n */\r\n\r\n// eslint-disable-next-line complexity\r\nfunction useColors() {\r\n\t// NB: In an Electron preload script, document will be defined but not fully\r\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\r\n\t// explicitly\r\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Internet Explorer and Edge do not support colors.\r\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\r\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\r\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\r\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\r\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\r\n\t\t// Is firefox >= v31?\r\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\r\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\r\n\t\t// Double check webkit in userAgent just in case we are in a worker\r\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\r\n}\r\n\r\n/**\r\n * Colorize log arguments if enabled.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction formatArgs(args) {\r\n\targs[0] = (this.useColors ? '%c' : '') +\r\n\t\tthis.namespace +\r\n\t\t(this.useColors ? ' %c' : ' ') +\r\n\t\targs[0] +\r\n\t\t(this.useColors ? '%c ' : ' ') +\r\n\t\t'+' + module.exports.humanize(this.diff);\r\n\r\n\tif (!this.useColors) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst c = 'color: ' + this.color;\r\n\targs.splice(1, 0, c, 'color: inherit');\r\n\r\n\t// The final \"%c\" is somewhat tricky, because there could be other\r\n\t// arguments passed either before or after the %c, so we need to\r\n\t// figure out the correct index to insert the CSS into\r\n\tlet index = 0;\r\n\tlet lastC = 0;\r\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\r\n\t\tif (match === '%%') {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tindex++;\r\n\t\tif (match === '%c') {\r\n\t\t\t// We only are interested in the *last* %c\r\n\t\t\t// (the user may have provided their own)\r\n\t\t\tlastC = index;\r\n\t\t}\r\n\t});\r\n\r\n\targs.splice(lastC, 0, c);\r\n}\r\n\r\n/**\r\n * Invokes `console.debug()` when available.\r\n * No-op when `console.debug` is not a \"function\".\r\n * If `console.debug` is not available, falls back\r\n * to `console.log`.\r\n *\r\n * @api public\r\n */\r\nexports.log = console.debug || console.log || (() => {});\r\n\r\n/**\r\n * Save `namespaces`.\r\n *\r\n * @param {String} namespaces\r\n * @api private\r\n */\r\nfunction save(namespaces) {\r\n\ttry {\r\n\t\tif (namespaces) {\r\n\t\t\texports.storage.setItem('debug', namespaces);\r\n\t\t} else {\r\n\t\t\texports.storage.removeItem('debug');\r\n\t\t}\r\n\t} catch (error) {\r\n\t\t// Swallow\r\n\t\t// XXX (@Qix-) should we be logging these?\r\n\t}\r\n}\r\n\r\n/**\r\n * Load `namespaces`.\r\n *\r\n * @return {String} returns the previously persisted debug modes\r\n * @api private\r\n */\r\nfunction load() {\r\n\tlet r;\r\n\ttry {\r\n\t\tr = exports.storage.getItem('debug');\r\n\t} catch (error) {\r\n\t\t// Swallow\r\n\t\t// XXX (@Qix-) should we be logging these?\r\n\t}\r\n\r\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\r\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\r\n\t\tr = process.env.DEBUG;\r\n\t}\r\n\r\n\treturn r;\r\n}\r\n\r\n/**\r\n * Localstorage attempts to return the localstorage.\r\n *\r\n * This is necessary because safari throws\r\n * when a user disables cookies/localstorage\r\n * and you attempt to access it.\r\n *\r\n * @return {LocalStorage}\r\n * @api private\r\n */\r\n\r\nfunction localstorage() {\r\n\ttry {\r\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\r\n\t\t// The Browser also has localStorage in the global context.\r\n\t\treturn localStorage;\r\n\t} catch (error) {\r\n\t\t// Swallow\r\n\t\t// XXX (@Qix-) should we be logging these?\r\n\t}\r\n}\r\n\r\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/engine.io-client/node_modules/debug/src/common.js\")(exports);\r\n\r\nconst {formatters} = module.exports;\r\n\r\n/**\r\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\r\n */\r\n\r\nformatters.j = function (v) {\r\n\ttry {\r\n\t\treturn JSON.stringify(v);\r\n\t} catch (error) {\r\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\r\n\t}\r\n};\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/node_modules/debug/src/common.js":
/*!************************************************************************!*\
  !*** ./node_modules/engine.io-client/node_modules/debug/src/common.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n/**\r\n * This is the common logic for both the Node.js and web browser\r\n * implementations of `debug()`.\r\n */\r\n\r\nfunction setup(env) {\r\n\tcreateDebug.debug = createDebug;\r\n\tcreateDebug.default = createDebug;\r\n\tcreateDebug.coerce = coerce;\r\n\tcreateDebug.disable = disable;\r\n\tcreateDebug.enable = enable;\r\n\tcreateDebug.enabled = enabled;\r\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/engine.io-client/node_modules/ms/index.js\");\r\n\tcreateDebug.destroy = destroy;\r\n\r\n\tObject.keys(env).forEach(key => {\r\n\t\tcreateDebug[key] = env[key];\r\n\t});\r\n\r\n\t/**\r\n\t* The currently active debug mode names, and names to skip.\r\n\t*/\r\n\r\n\tcreateDebug.names = [];\r\n\tcreateDebug.skips = [];\r\n\r\n\t/**\r\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\r\n\t*\r\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\r\n\t*/\r\n\tcreateDebug.formatters = {};\r\n\r\n\t/**\r\n\t* Selects a color for a debug namespace\r\n\t* @param {String} namespace The namespace string for the debug instance to be colored\r\n\t* @return {Number|String} An ANSI color code for the given namespace\r\n\t* @api private\r\n\t*/\r\n\tfunction selectColor(namespace) {\r\n\t\tlet hash = 0;\r\n\r\n\t\tfor (let i = 0; i < namespace.length; i++) {\r\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\r\n\t\t\thash |= 0; // Convert to 32bit integer\r\n\t\t}\r\n\r\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\r\n\t}\r\n\tcreateDebug.selectColor = selectColor;\r\n\r\n\t/**\r\n\t* Create a debugger with the given `namespace`.\r\n\t*\r\n\t* @param {String} namespace\r\n\t* @return {Function}\r\n\t* @api public\r\n\t*/\r\n\tfunction createDebug(namespace) {\r\n\t\tlet prevTime;\r\n\t\tlet enableOverride = null;\r\n\t\tlet namespacesCache;\r\n\t\tlet enabledCache;\r\n\r\n\t\tfunction debug(...args) {\r\n\t\t\t// Disabled?\r\n\t\t\tif (!debug.enabled) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tconst self = debug;\r\n\r\n\t\t\t// Set `diff` timestamp\r\n\t\t\tconst curr = Number(new Date());\r\n\t\t\tconst ms = curr - (prevTime || curr);\r\n\t\t\tself.diff = ms;\r\n\t\t\tself.prev = prevTime;\r\n\t\t\tself.curr = curr;\r\n\t\t\tprevTime = curr;\r\n\r\n\t\t\targs[0] = createDebug.coerce(args[0]);\r\n\r\n\t\t\tif (typeof args[0] !== 'string') {\r\n\t\t\t\t// Anything else let's inspect with %O\r\n\t\t\t\targs.unshift('%O');\r\n\t\t\t}\r\n\r\n\t\t\t// Apply any `formatters` transformations\r\n\t\t\tlet index = 0;\r\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\r\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\r\n\t\t\t\tif (match === '%%') {\r\n\t\t\t\t\treturn '%';\r\n\t\t\t\t}\r\n\t\t\t\tindex++;\r\n\t\t\t\tconst formatter = createDebug.formatters[format];\r\n\t\t\t\tif (typeof formatter === 'function') {\r\n\t\t\t\t\tconst val = args[index];\r\n\t\t\t\t\tmatch = formatter.call(self, val);\r\n\r\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\r\n\t\t\t\t\targs.splice(index, 1);\r\n\t\t\t\t\tindex--;\r\n\t\t\t\t}\r\n\t\t\t\treturn match;\r\n\t\t\t});\r\n\r\n\t\t\t// Apply env-specific formatting (colors, etc.)\r\n\t\t\tcreateDebug.formatArgs.call(self, args);\r\n\r\n\t\t\tconst logFn = self.log || createDebug.log;\r\n\t\t\tlogFn.apply(self, args);\r\n\t\t}\r\n\r\n\t\tdebug.namespace = namespace;\r\n\t\tdebug.useColors = createDebug.useColors();\r\n\t\tdebug.color = createDebug.selectColor(namespace);\r\n\t\tdebug.extend = extend;\r\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\r\n\r\n\t\tObject.defineProperty(debug, 'enabled', {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: () => {\r\n\t\t\t\tif (enableOverride !== null) {\r\n\t\t\t\t\treturn enableOverride;\r\n\t\t\t\t}\r\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\r\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\r\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn enabledCache;\r\n\t\t\t},\r\n\t\t\tset: v => {\r\n\t\t\t\tenableOverride = v;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Env-specific initialization logic for debug instances\r\n\t\tif (typeof createDebug.init === 'function') {\r\n\t\t\tcreateDebug.init(debug);\r\n\t\t}\r\n\r\n\t\treturn debug;\r\n\t}\r\n\r\n\tfunction extend(namespace, delimiter) {\r\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\r\n\t\tnewDebug.log = this.log;\r\n\t\treturn newDebug;\r\n\t}\r\n\r\n\t/**\r\n\t* Enables a debug mode by namespaces. This can include modes\r\n\t* separated by a colon and wildcards.\r\n\t*\r\n\t* @param {String} namespaces\r\n\t* @api public\r\n\t*/\r\n\tfunction enable(namespaces) {\r\n\t\tcreateDebug.save(namespaces);\r\n\t\tcreateDebug.namespaces = namespaces;\r\n\r\n\t\tcreateDebug.names = [];\r\n\t\tcreateDebug.skips = [];\r\n\r\n\t\tlet i;\r\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\r\n\t\tconst len = split.length;\r\n\r\n\t\tfor (i = 0; i < len; i++) {\r\n\t\t\tif (!split[i]) {\r\n\t\t\t\t// ignore empty strings\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\r\n\r\n\t\t\tif (namespaces[0] === '-') {\r\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\r\n\t\t\t} else {\r\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* Disable debug output.\r\n\t*\r\n\t* @return {String} namespaces\r\n\t* @api public\r\n\t*/\r\n\tfunction disable() {\r\n\t\tconst namespaces = [\r\n\t\t\t...createDebug.names.map(toNamespace),\r\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\r\n\t\t].join(',');\r\n\t\tcreateDebug.enable('');\r\n\t\treturn namespaces;\r\n\t}\r\n\r\n\t/**\r\n\t* Returns true if the given mode name is enabled, false otherwise.\r\n\t*\r\n\t* @param {String} name\r\n\t* @return {Boolean}\r\n\t* @api public\r\n\t*/\r\n\tfunction enabled(name) {\r\n\t\tif (name[name.length - 1] === '*') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tlet i;\r\n\t\tlet len;\r\n\r\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\r\n\t\t\tif (createDebug.skips[i].test(name)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\r\n\t\t\tif (createDebug.names[i].test(name)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t* Convert regexp to namespace\r\n\t*\r\n\t* @param {RegExp} regxep\r\n\t* @return {String} namespace\r\n\t* @api private\r\n\t*/\r\n\tfunction toNamespace(regexp) {\r\n\t\treturn regexp.toString()\r\n\t\t\t.substring(2, regexp.toString().length - 2)\r\n\t\t\t.replace(/\\.\\*\\?$/, '*');\r\n\t}\r\n\r\n\t/**\r\n\t* Coerce `val`.\r\n\t*\r\n\t* @param {Mixed} val\r\n\t* @return {Mixed}\r\n\t* @api private\r\n\t*/\r\n\tfunction coerce(val) {\r\n\t\tif (val instanceof Error) {\r\n\t\t\treturn val.stack || val.message;\r\n\t\t}\r\n\t\treturn val;\r\n\t}\r\n\r\n\t/**\r\n\t* XXX DO NOT USE. This is a temporary stub function.\r\n\t* XXX It WILL be removed in the next major release.\r\n\t*/\r\n\tfunction destroy() {\r\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\r\n\t}\r\n\r\n\tcreateDebug.enable(createDebug.load());\r\n\r\n\treturn createDebug;\r\n}\r\n\r\nmodule.exports = setup;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/node_modules/ms/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/engine.io-client/node_modules/ms/index.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("/**\r\n * Helpers.\r\n */\r\n\r\nvar s = 1000;\r\nvar m = s * 60;\r\nvar h = m * 60;\r\nvar d = h * 24;\r\nvar w = d * 7;\r\nvar y = d * 365.25;\r\n\r\n/**\r\n * Parse or format the given `val`.\r\n *\r\n * Options:\r\n *\r\n *  - `long` verbose formatting [false]\r\n *\r\n * @param {String|Number} val\r\n * @param {Object} [options]\r\n * @throws {Error} throw an error if val is not a non-empty string or a number\r\n * @return {String|Number}\r\n * @api public\r\n */\r\n\r\nmodule.exports = function(val, options) {\r\n  options = options || {};\r\n  var type = typeof val;\r\n  if (type === 'string' && val.length > 0) {\r\n    return parse(val);\r\n  } else if (type === 'number' && isFinite(val)) {\r\n    return options.long ? fmtLong(val) : fmtShort(val);\r\n  }\r\n  throw new Error(\r\n    'val is not a non-empty string or a valid number. val=' +\r\n      JSON.stringify(val)\r\n  );\r\n};\r\n\r\n/**\r\n * Parse the given `str` and return milliseconds.\r\n *\r\n * @param {String} str\r\n * @return {Number}\r\n * @api private\r\n */\r\n\r\nfunction parse(str) {\r\n  str = String(str);\r\n  if (str.length > 100) {\r\n    return;\r\n  }\r\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\r\n    str\r\n  );\r\n  if (!match) {\r\n    return;\r\n  }\r\n  var n = parseFloat(match[1]);\r\n  var type = (match[2] || 'ms').toLowerCase();\r\n  switch (type) {\r\n    case 'years':\r\n    case 'year':\r\n    case 'yrs':\r\n    case 'yr':\r\n    case 'y':\r\n      return n * y;\r\n    case 'weeks':\r\n    case 'week':\r\n    case 'w':\r\n      return n * w;\r\n    case 'days':\r\n    case 'day':\r\n    case 'd':\r\n      return n * d;\r\n    case 'hours':\r\n    case 'hour':\r\n    case 'hrs':\r\n    case 'hr':\r\n    case 'h':\r\n      return n * h;\r\n    case 'minutes':\r\n    case 'minute':\r\n    case 'mins':\r\n    case 'min':\r\n    case 'm':\r\n      return n * m;\r\n    case 'seconds':\r\n    case 'second':\r\n    case 'secs':\r\n    case 'sec':\r\n    case 's':\r\n      return n * s;\r\n    case 'milliseconds':\r\n    case 'millisecond':\r\n    case 'msecs':\r\n    case 'msec':\r\n    case 'ms':\r\n      return n;\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * Short format for `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction fmtShort(ms) {\r\n  var msAbs = Math.abs(ms);\r\n  if (msAbs >= d) {\r\n    return Math.round(ms / d) + 'd';\r\n  }\r\n  if (msAbs >= h) {\r\n    return Math.round(ms / h) + 'h';\r\n  }\r\n  if (msAbs >= m) {\r\n    return Math.round(ms / m) + 'm';\r\n  }\r\n  if (msAbs >= s) {\r\n    return Math.round(ms / s) + 's';\r\n  }\r\n  return ms + 'ms';\r\n}\r\n\r\n/**\r\n * Long format for `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction fmtLong(ms) {\r\n  var msAbs = Math.abs(ms);\r\n  if (msAbs >= d) {\r\n    return plural(ms, msAbs, d, 'day');\r\n  }\r\n  if (msAbs >= h) {\r\n    return plural(ms, msAbs, h, 'hour');\r\n  }\r\n  if (msAbs >= m) {\r\n    return plural(ms, msAbs, m, 'minute');\r\n  }\r\n  if (msAbs >= s) {\r\n    return plural(ms, msAbs, s, 'second');\r\n  }\r\n  return ms + ' ms';\r\n}\r\n\r\n/**\r\n * Pluralization helper.\r\n */\r\n\r\nfunction plural(ms, msAbs, n, name) {\r\n  var isPlural = msAbs >= n * 1.5;\r\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\r\n}\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/debug/src/browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/debug/src/browser.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */\r\n\r\n/**\r\n * This is the web browser implementation of `debug()`.\r\n */\r\n\r\nexports.formatArgs = formatArgs;\r\nexports.save = save;\r\nexports.load = load;\r\nexports.useColors = useColors;\r\nexports.storage = localstorage();\r\nexports.destroy = (() => {\r\n\tlet warned = false;\r\n\r\n\treturn () => {\r\n\t\tif (!warned) {\r\n\t\t\twarned = true;\r\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\r\n\t\t}\r\n\t};\r\n})();\r\n\r\n/**\r\n * Colors.\r\n */\r\n\r\nexports.colors = [\r\n\t'#0000CC',\r\n\t'#0000FF',\r\n\t'#0033CC',\r\n\t'#0033FF',\r\n\t'#0066CC',\r\n\t'#0066FF',\r\n\t'#0099CC',\r\n\t'#0099FF',\r\n\t'#00CC00',\r\n\t'#00CC33',\r\n\t'#00CC66',\r\n\t'#00CC99',\r\n\t'#00CCCC',\r\n\t'#00CCFF',\r\n\t'#3300CC',\r\n\t'#3300FF',\r\n\t'#3333CC',\r\n\t'#3333FF',\r\n\t'#3366CC',\r\n\t'#3366FF',\r\n\t'#3399CC',\r\n\t'#3399FF',\r\n\t'#33CC00',\r\n\t'#33CC33',\r\n\t'#33CC66',\r\n\t'#33CC99',\r\n\t'#33CCCC',\r\n\t'#33CCFF',\r\n\t'#6600CC',\r\n\t'#6600FF',\r\n\t'#6633CC',\r\n\t'#6633FF',\r\n\t'#66CC00',\r\n\t'#66CC33',\r\n\t'#9900CC',\r\n\t'#9900FF',\r\n\t'#9933CC',\r\n\t'#9933FF',\r\n\t'#99CC00',\r\n\t'#99CC33',\r\n\t'#CC0000',\r\n\t'#CC0033',\r\n\t'#CC0066',\r\n\t'#CC0099',\r\n\t'#CC00CC',\r\n\t'#CC00FF',\r\n\t'#CC3300',\r\n\t'#CC3333',\r\n\t'#CC3366',\r\n\t'#CC3399',\r\n\t'#CC33CC',\r\n\t'#CC33FF',\r\n\t'#CC6600',\r\n\t'#CC6633',\r\n\t'#CC9900',\r\n\t'#CC9933',\r\n\t'#CCCC00',\r\n\t'#CCCC33',\r\n\t'#FF0000',\r\n\t'#FF0033',\r\n\t'#FF0066',\r\n\t'#FF0099',\r\n\t'#FF00CC',\r\n\t'#FF00FF',\r\n\t'#FF3300',\r\n\t'#FF3333',\r\n\t'#FF3366',\r\n\t'#FF3399',\r\n\t'#FF33CC',\r\n\t'#FF33FF',\r\n\t'#FF6600',\r\n\t'#FF6633',\r\n\t'#FF9900',\r\n\t'#FF9933',\r\n\t'#FFCC00',\r\n\t'#FFCC33'\r\n];\r\n\r\n/**\r\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\r\n * and the Firebug extension (any Firefox version) are known\r\n * to support \"%c\" CSS customizations.\r\n *\r\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\r\n */\r\n\r\n// eslint-disable-next-line complexity\r\nfunction useColors() {\r\n\t// NB: In an Electron preload script, document will be defined but not fully\r\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\r\n\t// explicitly\r\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Internet Explorer and Edge do not support colors.\r\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\r\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\r\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\r\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\r\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\r\n\t\t// Is firefox >= v31?\r\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\r\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\r\n\t\t// Double check webkit in userAgent just in case we are in a worker\r\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\r\n}\r\n\r\n/**\r\n * Colorize log arguments if enabled.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction formatArgs(args) {\r\n\targs[0] = (this.useColors ? '%c' : '') +\r\n\t\tthis.namespace +\r\n\t\t(this.useColors ? ' %c' : ' ') +\r\n\t\targs[0] +\r\n\t\t(this.useColors ? '%c ' : ' ') +\r\n\t\t'+' + module.exports.humanize(this.diff);\r\n\r\n\tif (!this.useColors) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst c = 'color: ' + this.color;\r\n\targs.splice(1, 0, c, 'color: inherit');\r\n\r\n\t// The final \"%c\" is somewhat tricky, because there could be other\r\n\t// arguments passed either before or after the %c, so we need to\r\n\t// figure out the correct index to insert the CSS into\r\n\tlet index = 0;\r\n\tlet lastC = 0;\r\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\r\n\t\tif (match === '%%') {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tindex++;\r\n\t\tif (match === '%c') {\r\n\t\t\t// We only are interested in the *last* %c\r\n\t\t\t// (the user may have provided their own)\r\n\t\t\tlastC = index;\r\n\t\t}\r\n\t});\r\n\r\n\targs.splice(lastC, 0, c);\r\n}\r\n\r\n/**\r\n * Invokes `console.debug()` when available.\r\n * No-op when `console.debug` is not a \"function\".\r\n * If `console.debug` is not available, falls back\r\n * to `console.log`.\r\n *\r\n * @api public\r\n */\r\nexports.log = console.debug || console.log || (() => {});\r\n\r\n/**\r\n * Save `namespaces`.\r\n *\r\n * @param {String} namespaces\r\n * @api private\r\n */\r\nfunction save(namespaces) {\r\n\ttry {\r\n\t\tif (namespaces) {\r\n\t\t\texports.storage.setItem('debug', namespaces);\r\n\t\t} else {\r\n\t\t\texports.storage.removeItem('debug');\r\n\t\t}\r\n\t} catch (error) {\r\n\t\t// Swallow\r\n\t\t// XXX (@Qix-) should we be logging these?\r\n\t}\r\n}\r\n\r\n/**\r\n * Load `namespaces`.\r\n *\r\n * @return {String} returns the previously persisted debug modes\r\n * @api private\r\n */\r\nfunction load() {\r\n\tlet r;\r\n\ttry {\r\n\t\tr = exports.storage.getItem('debug');\r\n\t} catch (error) {\r\n\t\t// Swallow\r\n\t\t// XXX (@Qix-) should we be logging these?\r\n\t}\r\n\r\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\r\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\r\n\t\tr = process.env.DEBUG;\r\n\t}\r\n\r\n\treturn r;\r\n}\r\n\r\n/**\r\n * Localstorage attempts to return the localstorage.\r\n *\r\n * This is necessary because safari throws\r\n * when a user disables cookies/localstorage\r\n * and you attempt to access it.\r\n *\r\n * @return {LocalStorage}\r\n * @api private\r\n */\r\n\r\nfunction localstorage() {\r\n\ttry {\r\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\r\n\t\t// The Browser also has localStorage in the global context.\r\n\t\treturn localStorage;\r\n\t} catch (error) {\r\n\t\t// Swallow\r\n\t\t// XXX (@Qix-) should we be logging these?\r\n\t}\r\n}\r\n\r\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/socket.io-client/node_modules/debug/src/common.js\")(exports);\r\n\r\nconst {formatters} = module.exports;\r\n\r\n/**\r\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\r\n */\r\n\r\nformatters.j = function (v) {\r\n\ttry {\r\n\t\treturn JSON.stringify(v);\r\n\t} catch (error) {\r\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\r\n\t}\r\n};\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/socket.io-client/node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/debug/src/common.js":
/*!************************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/debug/src/common.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n/**\r\n * This is the common logic for both the Node.js and web browser\r\n * implementations of `debug()`.\r\n */\r\n\r\nfunction setup(env) {\r\n\tcreateDebug.debug = createDebug;\r\n\tcreateDebug.default = createDebug;\r\n\tcreateDebug.coerce = coerce;\r\n\tcreateDebug.disable = disable;\r\n\tcreateDebug.enable = enable;\r\n\tcreateDebug.enabled = enabled;\r\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/socket.io-client/node_modules/ms/index.js\");\r\n\tcreateDebug.destroy = destroy;\r\n\r\n\tObject.keys(env).forEach(key => {\r\n\t\tcreateDebug[key] = env[key];\r\n\t});\r\n\r\n\t/**\r\n\t* The currently active debug mode names, and names to skip.\r\n\t*/\r\n\r\n\tcreateDebug.names = [];\r\n\tcreateDebug.skips = [];\r\n\r\n\t/**\r\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\r\n\t*\r\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\r\n\t*/\r\n\tcreateDebug.formatters = {};\r\n\r\n\t/**\r\n\t* Selects a color for a debug namespace\r\n\t* @param {String} namespace The namespace string for the debug instance to be colored\r\n\t* @return {Number|String} An ANSI color code for the given namespace\r\n\t* @api private\r\n\t*/\r\n\tfunction selectColor(namespace) {\r\n\t\tlet hash = 0;\r\n\r\n\t\tfor (let i = 0; i < namespace.length; i++) {\r\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\r\n\t\t\thash |= 0; // Convert to 32bit integer\r\n\t\t}\r\n\r\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\r\n\t}\r\n\tcreateDebug.selectColor = selectColor;\r\n\r\n\t/**\r\n\t* Create a debugger with the given `namespace`.\r\n\t*\r\n\t* @param {String} namespace\r\n\t* @return {Function}\r\n\t* @api public\r\n\t*/\r\n\tfunction createDebug(namespace) {\r\n\t\tlet prevTime;\r\n\t\tlet enableOverride = null;\r\n\t\tlet namespacesCache;\r\n\t\tlet enabledCache;\r\n\r\n\t\tfunction debug(...args) {\r\n\t\t\t// Disabled?\r\n\t\t\tif (!debug.enabled) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tconst self = debug;\r\n\r\n\t\t\t// Set `diff` timestamp\r\n\t\t\tconst curr = Number(new Date());\r\n\t\t\tconst ms = curr - (prevTime || curr);\r\n\t\t\tself.diff = ms;\r\n\t\t\tself.prev = prevTime;\r\n\t\t\tself.curr = curr;\r\n\t\t\tprevTime = curr;\r\n\r\n\t\t\targs[0] = createDebug.coerce(args[0]);\r\n\r\n\t\t\tif (typeof args[0] !== 'string') {\r\n\t\t\t\t// Anything else let's inspect with %O\r\n\t\t\t\targs.unshift('%O');\r\n\t\t\t}\r\n\r\n\t\t\t// Apply any `formatters` transformations\r\n\t\t\tlet index = 0;\r\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\r\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\r\n\t\t\t\tif (match === '%%') {\r\n\t\t\t\t\treturn '%';\r\n\t\t\t\t}\r\n\t\t\t\tindex++;\r\n\t\t\t\tconst formatter = createDebug.formatters[format];\r\n\t\t\t\tif (typeof formatter === 'function') {\r\n\t\t\t\t\tconst val = args[index];\r\n\t\t\t\t\tmatch = formatter.call(self, val);\r\n\r\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\r\n\t\t\t\t\targs.splice(index, 1);\r\n\t\t\t\t\tindex--;\r\n\t\t\t\t}\r\n\t\t\t\treturn match;\r\n\t\t\t});\r\n\r\n\t\t\t// Apply env-specific formatting (colors, etc.)\r\n\t\t\tcreateDebug.formatArgs.call(self, args);\r\n\r\n\t\t\tconst logFn = self.log || createDebug.log;\r\n\t\t\tlogFn.apply(self, args);\r\n\t\t}\r\n\r\n\t\tdebug.namespace = namespace;\r\n\t\tdebug.useColors = createDebug.useColors();\r\n\t\tdebug.color = createDebug.selectColor(namespace);\r\n\t\tdebug.extend = extend;\r\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\r\n\r\n\t\tObject.defineProperty(debug, 'enabled', {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: () => {\r\n\t\t\t\tif (enableOverride !== null) {\r\n\t\t\t\t\treturn enableOverride;\r\n\t\t\t\t}\r\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\r\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\r\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn enabledCache;\r\n\t\t\t},\r\n\t\t\tset: v => {\r\n\t\t\t\tenableOverride = v;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Env-specific initialization logic for debug instances\r\n\t\tif (typeof createDebug.init === 'function') {\r\n\t\t\tcreateDebug.init(debug);\r\n\t\t}\r\n\r\n\t\treturn debug;\r\n\t}\r\n\r\n\tfunction extend(namespace, delimiter) {\r\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\r\n\t\tnewDebug.log = this.log;\r\n\t\treturn newDebug;\r\n\t}\r\n\r\n\t/**\r\n\t* Enables a debug mode by namespaces. This can include modes\r\n\t* separated by a colon and wildcards.\r\n\t*\r\n\t* @param {String} namespaces\r\n\t* @api public\r\n\t*/\r\n\tfunction enable(namespaces) {\r\n\t\tcreateDebug.save(namespaces);\r\n\t\tcreateDebug.namespaces = namespaces;\r\n\r\n\t\tcreateDebug.names = [];\r\n\t\tcreateDebug.skips = [];\r\n\r\n\t\tlet i;\r\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\r\n\t\tconst len = split.length;\r\n\r\n\t\tfor (i = 0; i < len; i++) {\r\n\t\t\tif (!split[i]) {\r\n\t\t\t\t// ignore empty strings\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\r\n\r\n\t\t\tif (namespaces[0] === '-') {\r\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\r\n\t\t\t} else {\r\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* Disable debug output.\r\n\t*\r\n\t* @return {String} namespaces\r\n\t* @api public\r\n\t*/\r\n\tfunction disable() {\r\n\t\tconst namespaces = [\r\n\t\t\t...createDebug.names.map(toNamespace),\r\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\r\n\t\t].join(',');\r\n\t\tcreateDebug.enable('');\r\n\t\treturn namespaces;\r\n\t}\r\n\r\n\t/**\r\n\t* Returns true if the given mode name is enabled, false otherwise.\r\n\t*\r\n\t* @param {String} name\r\n\t* @return {Boolean}\r\n\t* @api public\r\n\t*/\r\n\tfunction enabled(name) {\r\n\t\tif (name[name.length - 1] === '*') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tlet i;\r\n\t\tlet len;\r\n\r\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\r\n\t\t\tif (createDebug.skips[i].test(name)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\r\n\t\t\tif (createDebug.names[i].test(name)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t* Convert regexp to namespace\r\n\t*\r\n\t* @param {RegExp} regxep\r\n\t* @return {String} namespace\r\n\t* @api private\r\n\t*/\r\n\tfunction toNamespace(regexp) {\r\n\t\treturn regexp.toString()\r\n\t\t\t.substring(2, regexp.toString().length - 2)\r\n\t\t\t.replace(/\\.\\*\\?$/, '*');\r\n\t}\r\n\r\n\t/**\r\n\t* Coerce `val`.\r\n\t*\r\n\t* @param {Mixed} val\r\n\t* @return {Mixed}\r\n\t* @api private\r\n\t*/\r\n\tfunction coerce(val) {\r\n\t\tif (val instanceof Error) {\r\n\t\t\treturn val.stack || val.message;\r\n\t\t}\r\n\t\treturn val;\r\n\t}\r\n\r\n\t/**\r\n\t* XXX DO NOT USE. This is a temporary stub function.\r\n\t* XXX It WILL be removed in the next major release.\r\n\t*/\r\n\tfunction destroy() {\r\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\r\n\t}\r\n\r\n\tcreateDebug.enable(createDebug.load());\r\n\r\n\treturn createDebug;\r\n}\r\n\r\nmodule.exports = setup;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/socket.io-client/node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/ms/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/ms/index.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("/**\r\n * Helpers.\r\n */\r\n\r\nvar s = 1000;\r\nvar m = s * 60;\r\nvar h = m * 60;\r\nvar d = h * 24;\r\nvar w = d * 7;\r\nvar y = d * 365.25;\r\n\r\n/**\r\n * Parse or format the given `val`.\r\n *\r\n * Options:\r\n *\r\n *  - `long` verbose formatting [false]\r\n *\r\n * @param {String|Number} val\r\n * @param {Object} [options]\r\n * @throws {Error} throw an error if val is not a non-empty string or a number\r\n * @return {String|Number}\r\n * @api public\r\n */\r\n\r\nmodule.exports = function(val, options) {\r\n  options = options || {};\r\n  var type = typeof val;\r\n  if (type === 'string' && val.length > 0) {\r\n    return parse(val);\r\n  } else if (type === 'number' && isFinite(val)) {\r\n    return options.long ? fmtLong(val) : fmtShort(val);\r\n  }\r\n  throw new Error(\r\n    'val is not a non-empty string or a valid number. val=' +\r\n      JSON.stringify(val)\r\n  );\r\n};\r\n\r\n/**\r\n * Parse the given `str` and return milliseconds.\r\n *\r\n * @param {String} str\r\n * @return {Number}\r\n * @api private\r\n */\r\n\r\nfunction parse(str) {\r\n  str = String(str);\r\n  if (str.length > 100) {\r\n    return;\r\n  }\r\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\r\n    str\r\n  );\r\n  if (!match) {\r\n    return;\r\n  }\r\n  var n = parseFloat(match[1]);\r\n  var type = (match[2] || 'ms').toLowerCase();\r\n  switch (type) {\r\n    case 'years':\r\n    case 'year':\r\n    case 'yrs':\r\n    case 'yr':\r\n    case 'y':\r\n      return n * y;\r\n    case 'weeks':\r\n    case 'week':\r\n    case 'w':\r\n      return n * w;\r\n    case 'days':\r\n    case 'day':\r\n    case 'd':\r\n      return n * d;\r\n    case 'hours':\r\n    case 'hour':\r\n    case 'hrs':\r\n    case 'hr':\r\n    case 'h':\r\n      return n * h;\r\n    case 'minutes':\r\n    case 'minute':\r\n    case 'mins':\r\n    case 'min':\r\n    case 'm':\r\n      return n * m;\r\n    case 'seconds':\r\n    case 'second':\r\n    case 'secs':\r\n    case 'sec':\r\n    case 's':\r\n      return n * s;\r\n    case 'milliseconds':\r\n    case 'millisecond':\r\n    case 'msecs':\r\n    case 'msec':\r\n    case 'ms':\r\n      return n;\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * Short format for `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction fmtShort(ms) {\r\n  var msAbs = Math.abs(ms);\r\n  if (msAbs >= d) {\r\n    return Math.round(ms / d) + 'd';\r\n  }\r\n  if (msAbs >= h) {\r\n    return Math.round(ms / h) + 'h';\r\n  }\r\n  if (msAbs >= m) {\r\n    return Math.round(ms / m) + 'm';\r\n  }\r\n  if (msAbs >= s) {\r\n    return Math.round(ms / s) + 's';\r\n  }\r\n  return ms + 'ms';\r\n}\r\n\r\n/**\r\n * Long format for `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction fmtLong(ms) {\r\n  var msAbs = Math.abs(ms);\r\n  if (msAbs >= d) {\r\n    return plural(ms, msAbs, d, 'day');\r\n  }\r\n  if (msAbs >= h) {\r\n    return plural(ms, msAbs, h, 'hour');\r\n  }\r\n  if (msAbs >= m) {\r\n    return plural(ms, msAbs, m, 'minute');\r\n  }\r\n  if (msAbs >= s) {\r\n    return plural(ms, msAbs, s, 'second');\r\n  }\r\n  return ms + ' ms';\r\n}\r\n\r\n/**\r\n * Pluralization helper.\r\n */\r\n\r\nfunction plural(ms, msAbs, n, name) {\r\n  var isPlural = msAbs >= n * 1.5;\r\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\r\n}\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/socket.io-client/node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/socket.io-parser/node_modules/debug/src/browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/socket.io-parser/node_modules/debug/src/browser.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */\r\n\r\n/**\r\n * This is the web browser implementation of `debug()`.\r\n */\r\n\r\nexports.formatArgs = formatArgs;\r\nexports.save = save;\r\nexports.load = load;\r\nexports.useColors = useColors;\r\nexports.storage = localstorage();\r\nexports.destroy = (() => {\r\n\tlet warned = false;\r\n\r\n\treturn () => {\r\n\t\tif (!warned) {\r\n\t\t\twarned = true;\r\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\r\n\t\t}\r\n\t};\r\n})();\r\n\r\n/**\r\n * Colors.\r\n */\r\n\r\nexports.colors = [\r\n\t'#0000CC',\r\n\t'#0000FF',\r\n\t'#0033CC',\r\n\t'#0033FF',\r\n\t'#0066CC',\r\n\t'#0066FF',\r\n\t'#0099CC',\r\n\t'#0099FF',\r\n\t'#00CC00',\r\n\t'#00CC33',\r\n\t'#00CC66',\r\n\t'#00CC99',\r\n\t'#00CCCC',\r\n\t'#00CCFF',\r\n\t'#3300CC',\r\n\t'#3300FF',\r\n\t'#3333CC',\r\n\t'#3333FF',\r\n\t'#3366CC',\r\n\t'#3366FF',\r\n\t'#3399CC',\r\n\t'#3399FF',\r\n\t'#33CC00',\r\n\t'#33CC33',\r\n\t'#33CC66',\r\n\t'#33CC99',\r\n\t'#33CCCC',\r\n\t'#33CCFF',\r\n\t'#6600CC',\r\n\t'#6600FF',\r\n\t'#6633CC',\r\n\t'#6633FF',\r\n\t'#66CC00',\r\n\t'#66CC33',\r\n\t'#9900CC',\r\n\t'#9900FF',\r\n\t'#9933CC',\r\n\t'#9933FF',\r\n\t'#99CC00',\r\n\t'#99CC33',\r\n\t'#CC0000',\r\n\t'#CC0033',\r\n\t'#CC0066',\r\n\t'#CC0099',\r\n\t'#CC00CC',\r\n\t'#CC00FF',\r\n\t'#CC3300',\r\n\t'#CC3333',\r\n\t'#CC3366',\r\n\t'#CC3399',\r\n\t'#CC33CC',\r\n\t'#CC33FF',\r\n\t'#CC6600',\r\n\t'#CC6633',\r\n\t'#CC9900',\r\n\t'#CC9933',\r\n\t'#CCCC00',\r\n\t'#CCCC33',\r\n\t'#FF0000',\r\n\t'#FF0033',\r\n\t'#FF0066',\r\n\t'#FF0099',\r\n\t'#FF00CC',\r\n\t'#FF00FF',\r\n\t'#FF3300',\r\n\t'#FF3333',\r\n\t'#FF3366',\r\n\t'#FF3399',\r\n\t'#FF33CC',\r\n\t'#FF33FF',\r\n\t'#FF6600',\r\n\t'#FF6633',\r\n\t'#FF9900',\r\n\t'#FF9933',\r\n\t'#FFCC00',\r\n\t'#FFCC33'\r\n];\r\n\r\n/**\r\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\r\n * and the Firebug extension (any Firefox version) are known\r\n * to support \"%c\" CSS customizations.\r\n *\r\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\r\n */\r\n\r\n// eslint-disable-next-line complexity\r\nfunction useColors() {\r\n\t// NB: In an Electron preload script, document will be defined but not fully\r\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\r\n\t// explicitly\r\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Internet Explorer and Edge do not support colors.\r\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\r\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\r\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\r\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\r\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\r\n\t\t// Is firefox >= v31?\r\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\r\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\r\n\t\t// Double check webkit in userAgent just in case we are in a worker\r\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\r\n}\r\n\r\n/**\r\n * Colorize log arguments if enabled.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction formatArgs(args) {\r\n\targs[0] = (this.useColors ? '%c' : '') +\r\n\t\tthis.namespace +\r\n\t\t(this.useColors ? ' %c' : ' ') +\r\n\t\targs[0] +\r\n\t\t(this.useColors ? '%c ' : ' ') +\r\n\t\t'+' + module.exports.humanize(this.diff);\r\n\r\n\tif (!this.useColors) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst c = 'color: ' + this.color;\r\n\targs.splice(1, 0, c, 'color: inherit');\r\n\r\n\t// The final \"%c\" is somewhat tricky, because there could be other\r\n\t// arguments passed either before or after the %c, so we need to\r\n\t// figure out the correct index to insert the CSS into\r\n\tlet index = 0;\r\n\tlet lastC = 0;\r\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\r\n\t\tif (match === '%%') {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tindex++;\r\n\t\tif (match === '%c') {\r\n\t\t\t// We only are interested in the *last* %c\r\n\t\t\t// (the user may have provided their own)\r\n\t\t\tlastC = index;\r\n\t\t}\r\n\t});\r\n\r\n\targs.splice(lastC, 0, c);\r\n}\r\n\r\n/**\r\n * Invokes `console.debug()` when available.\r\n * No-op when `console.debug` is not a \"function\".\r\n * If `console.debug` is not available, falls back\r\n * to `console.log`.\r\n *\r\n * @api public\r\n */\r\nexports.log = console.debug || console.log || (() => {});\r\n\r\n/**\r\n * Save `namespaces`.\r\n *\r\n * @param {String} namespaces\r\n * @api private\r\n */\r\nfunction save(namespaces) {\r\n\ttry {\r\n\t\tif (namespaces) {\r\n\t\t\texports.storage.setItem('debug', namespaces);\r\n\t\t} else {\r\n\t\t\texports.storage.removeItem('debug');\r\n\t\t}\r\n\t} catch (error) {\r\n\t\t// Swallow\r\n\t\t// XXX (@Qix-) should we be logging these?\r\n\t}\r\n}\r\n\r\n/**\r\n * Load `namespaces`.\r\n *\r\n * @return {String} returns the previously persisted debug modes\r\n * @api private\r\n */\r\nfunction load() {\r\n\tlet r;\r\n\ttry {\r\n\t\tr = exports.storage.getItem('debug');\r\n\t} catch (error) {\r\n\t\t// Swallow\r\n\t\t// XXX (@Qix-) should we be logging these?\r\n\t}\r\n\r\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\r\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\r\n\t\tr = process.env.DEBUG;\r\n\t}\r\n\r\n\treturn r;\r\n}\r\n\r\n/**\r\n * Localstorage attempts to return the localstorage.\r\n *\r\n * This is necessary because safari throws\r\n * when a user disables cookies/localstorage\r\n * and you attempt to access it.\r\n *\r\n * @return {LocalStorage}\r\n * @api private\r\n */\r\n\r\nfunction localstorage() {\r\n\ttry {\r\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\r\n\t\t// The Browser also has localStorage in the global context.\r\n\t\treturn localStorage;\r\n\t} catch (error) {\r\n\t\t// Swallow\r\n\t\t// XXX (@Qix-) should we be logging these?\r\n\t}\r\n}\r\n\r\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/socket.io-parser/node_modules/debug/src/common.js\")(exports);\r\n\r\nconst {formatters} = module.exports;\r\n\r\n/**\r\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\r\n */\r\n\r\nformatters.j = function (v) {\r\n\ttry {\r\n\t\treturn JSON.stringify(v);\r\n\t} catch (error) {\r\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\r\n\t}\r\n};\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/socket.io-parser/node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/socket.io-parser/node_modules/debug/src/common.js":
/*!************************************************************************!*\
  !*** ./node_modules/socket.io-parser/node_modules/debug/src/common.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n/**\r\n * This is the common logic for both the Node.js and web browser\r\n * implementations of `debug()`.\r\n */\r\n\r\nfunction setup(env) {\r\n\tcreateDebug.debug = createDebug;\r\n\tcreateDebug.default = createDebug;\r\n\tcreateDebug.coerce = coerce;\r\n\tcreateDebug.disable = disable;\r\n\tcreateDebug.enable = enable;\r\n\tcreateDebug.enabled = enabled;\r\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/socket.io-parser/node_modules/ms/index.js\");\r\n\tcreateDebug.destroy = destroy;\r\n\r\n\tObject.keys(env).forEach(key => {\r\n\t\tcreateDebug[key] = env[key];\r\n\t});\r\n\r\n\t/**\r\n\t* The currently active debug mode names, and names to skip.\r\n\t*/\r\n\r\n\tcreateDebug.names = [];\r\n\tcreateDebug.skips = [];\r\n\r\n\t/**\r\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\r\n\t*\r\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\r\n\t*/\r\n\tcreateDebug.formatters = {};\r\n\r\n\t/**\r\n\t* Selects a color for a debug namespace\r\n\t* @param {String} namespace The namespace string for the debug instance to be colored\r\n\t* @return {Number|String} An ANSI color code for the given namespace\r\n\t* @api private\r\n\t*/\r\n\tfunction selectColor(namespace) {\r\n\t\tlet hash = 0;\r\n\r\n\t\tfor (let i = 0; i < namespace.length; i++) {\r\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\r\n\t\t\thash |= 0; // Convert to 32bit integer\r\n\t\t}\r\n\r\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\r\n\t}\r\n\tcreateDebug.selectColor = selectColor;\r\n\r\n\t/**\r\n\t* Create a debugger with the given `namespace`.\r\n\t*\r\n\t* @param {String} namespace\r\n\t* @return {Function}\r\n\t* @api public\r\n\t*/\r\n\tfunction createDebug(namespace) {\r\n\t\tlet prevTime;\r\n\t\tlet enableOverride = null;\r\n\t\tlet namespacesCache;\r\n\t\tlet enabledCache;\r\n\r\n\t\tfunction debug(...args) {\r\n\t\t\t// Disabled?\r\n\t\t\tif (!debug.enabled) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tconst self = debug;\r\n\r\n\t\t\t// Set `diff` timestamp\r\n\t\t\tconst curr = Number(new Date());\r\n\t\t\tconst ms = curr - (prevTime || curr);\r\n\t\t\tself.diff = ms;\r\n\t\t\tself.prev = prevTime;\r\n\t\t\tself.curr = curr;\r\n\t\t\tprevTime = curr;\r\n\r\n\t\t\targs[0] = createDebug.coerce(args[0]);\r\n\r\n\t\t\tif (typeof args[0] !== 'string') {\r\n\t\t\t\t// Anything else let's inspect with %O\r\n\t\t\t\targs.unshift('%O');\r\n\t\t\t}\r\n\r\n\t\t\t// Apply any `formatters` transformations\r\n\t\t\tlet index = 0;\r\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\r\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\r\n\t\t\t\tif (match === '%%') {\r\n\t\t\t\t\treturn '%';\r\n\t\t\t\t}\r\n\t\t\t\tindex++;\r\n\t\t\t\tconst formatter = createDebug.formatters[format];\r\n\t\t\t\tif (typeof formatter === 'function') {\r\n\t\t\t\t\tconst val = args[index];\r\n\t\t\t\t\tmatch = formatter.call(self, val);\r\n\r\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\r\n\t\t\t\t\targs.splice(index, 1);\r\n\t\t\t\t\tindex--;\r\n\t\t\t\t}\r\n\t\t\t\treturn match;\r\n\t\t\t});\r\n\r\n\t\t\t// Apply env-specific formatting (colors, etc.)\r\n\t\t\tcreateDebug.formatArgs.call(self, args);\r\n\r\n\t\t\tconst logFn = self.log || createDebug.log;\r\n\t\t\tlogFn.apply(self, args);\r\n\t\t}\r\n\r\n\t\tdebug.namespace = namespace;\r\n\t\tdebug.useColors = createDebug.useColors();\r\n\t\tdebug.color = createDebug.selectColor(namespace);\r\n\t\tdebug.extend = extend;\r\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\r\n\r\n\t\tObject.defineProperty(debug, 'enabled', {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: () => {\r\n\t\t\t\tif (enableOverride !== null) {\r\n\t\t\t\t\treturn enableOverride;\r\n\t\t\t\t}\r\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\r\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\r\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn enabledCache;\r\n\t\t\t},\r\n\t\t\tset: v => {\r\n\t\t\t\tenableOverride = v;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Env-specific initialization logic for debug instances\r\n\t\tif (typeof createDebug.init === 'function') {\r\n\t\t\tcreateDebug.init(debug);\r\n\t\t}\r\n\r\n\t\treturn debug;\r\n\t}\r\n\r\n\tfunction extend(namespace, delimiter) {\r\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\r\n\t\tnewDebug.log = this.log;\r\n\t\treturn newDebug;\r\n\t}\r\n\r\n\t/**\r\n\t* Enables a debug mode by namespaces. This can include modes\r\n\t* separated by a colon and wildcards.\r\n\t*\r\n\t* @param {String} namespaces\r\n\t* @api public\r\n\t*/\r\n\tfunction enable(namespaces) {\r\n\t\tcreateDebug.save(namespaces);\r\n\t\tcreateDebug.namespaces = namespaces;\r\n\r\n\t\tcreateDebug.names = [];\r\n\t\tcreateDebug.skips = [];\r\n\r\n\t\tlet i;\r\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\r\n\t\tconst len = split.length;\r\n\r\n\t\tfor (i = 0; i < len; i++) {\r\n\t\t\tif (!split[i]) {\r\n\t\t\t\t// ignore empty strings\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\r\n\r\n\t\t\tif (namespaces[0] === '-') {\r\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\r\n\t\t\t} else {\r\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* Disable debug output.\r\n\t*\r\n\t* @return {String} namespaces\r\n\t* @api public\r\n\t*/\r\n\tfunction disable() {\r\n\t\tconst namespaces = [\r\n\t\t\t...createDebug.names.map(toNamespace),\r\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\r\n\t\t].join(',');\r\n\t\tcreateDebug.enable('');\r\n\t\treturn namespaces;\r\n\t}\r\n\r\n\t/**\r\n\t* Returns true if the given mode name is enabled, false otherwise.\r\n\t*\r\n\t* @param {String} name\r\n\t* @return {Boolean}\r\n\t* @api public\r\n\t*/\r\n\tfunction enabled(name) {\r\n\t\tif (name[name.length - 1] === '*') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tlet i;\r\n\t\tlet len;\r\n\r\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\r\n\t\t\tif (createDebug.skips[i].test(name)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\r\n\t\t\tif (createDebug.names[i].test(name)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t* Convert regexp to namespace\r\n\t*\r\n\t* @param {RegExp} regxep\r\n\t* @return {String} namespace\r\n\t* @api private\r\n\t*/\r\n\tfunction toNamespace(regexp) {\r\n\t\treturn regexp.toString()\r\n\t\t\t.substring(2, regexp.toString().length - 2)\r\n\t\t\t.replace(/\\.\\*\\?$/, '*');\r\n\t}\r\n\r\n\t/**\r\n\t* Coerce `val`.\r\n\t*\r\n\t* @param {Mixed} val\r\n\t* @return {Mixed}\r\n\t* @api private\r\n\t*/\r\n\tfunction coerce(val) {\r\n\t\tif (val instanceof Error) {\r\n\t\t\treturn val.stack || val.message;\r\n\t\t}\r\n\t\treturn val;\r\n\t}\r\n\r\n\t/**\r\n\t* XXX DO NOT USE. This is a temporary stub function.\r\n\t* XXX It WILL be removed in the next major release.\r\n\t*/\r\n\tfunction destroy() {\r\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\r\n\t}\r\n\r\n\tcreateDebug.enable(createDebug.load());\r\n\r\n\treturn createDebug;\r\n}\r\n\r\nmodule.exports = setup;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/socket.io-parser/node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/socket.io-parser/node_modules/ms/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/socket.io-parser/node_modules/ms/index.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("/**\r\n * Helpers.\r\n */\r\n\r\nvar s = 1000;\r\nvar m = s * 60;\r\nvar h = m * 60;\r\nvar d = h * 24;\r\nvar w = d * 7;\r\nvar y = d * 365.25;\r\n\r\n/**\r\n * Parse or format the given `val`.\r\n *\r\n * Options:\r\n *\r\n *  - `long` verbose formatting [false]\r\n *\r\n * @param {String|Number} val\r\n * @param {Object} [options]\r\n * @throws {Error} throw an error if val is not a non-empty string or a number\r\n * @return {String|Number}\r\n * @api public\r\n */\r\n\r\nmodule.exports = function(val, options) {\r\n  options = options || {};\r\n  var type = typeof val;\r\n  if (type === 'string' && val.length > 0) {\r\n    return parse(val);\r\n  } else if (type === 'number' && isFinite(val)) {\r\n    return options.long ? fmtLong(val) : fmtShort(val);\r\n  }\r\n  throw new Error(\r\n    'val is not a non-empty string or a valid number. val=' +\r\n      JSON.stringify(val)\r\n  );\r\n};\r\n\r\n/**\r\n * Parse the given `str` and return milliseconds.\r\n *\r\n * @param {String} str\r\n * @return {Number}\r\n * @api private\r\n */\r\n\r\nfunction parse(str) {\r\n  str = String(str);\r\n  if (str.length > 100) {\r\n    return;\r\n  }\r\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\r\n    str\r\n  );\r\n  if (!match) {\r\n    return;\r\n  }\r\n  var n = parseFloat(match[1]);\r\n  var type = (match[2] || 'ms').toLowerCase();\r\n  switch (type) {\r\n    case 'years':\r\n    case 'year':\r\n    case 'yrs':\r\n    case 'yr':\r\n    case 'y':\r\n      return n * y;\r\n    case 'weeks':\r\n    case 'week':\r\n    case 'w':\r\n      return n * w;\r\n    case 'days':\r\n    case 'day':\r\n    case 'd':\r\n      return n * d;\r\n    case 'hours':\r\n    case 'hour':\r\n    case 'hrs':\r\n    case 'hr':\r\n    case 'h':\r\n      return n * h;\r\n    case 'minutes':\r\n    case 'minute':\r\n    case 'mins':\r\n    case 'min':\r\n    case 'm':\r\n      return n * m;\r\n    case 'seconds':\r\n    case 'second':\r\n    case 'secs':\r\n    case 'sec':\r\n    case 's':\r\n      return n * s;\r\n    case 'milliseconds':\r\n    case 'millisecond':\r\n    case 'msecs':\r\n    case 'msec':\r\n    case 'ms':\r\n      return n;\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * Short format for `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction fmtShort(ms) {\r\n  var msAbs = Math.abs(ms);\r\n  if (msAbs >= d) {\r\n    return Math.round(ms / d) + 'd';\r\n  }\r\n  if (msAbs >= h) {\r\n    return Math.round(ms / h) + 'h';\r\n  }\r\n  if (msAbs >= m) {\r\n    return Math.round(ms / m) + 'm';\r\n  }\r\n  if (msAbs >= s) {\r\n    return Math.round(ms / s) + 's';\r\n  }\r\n  return ms + 'ms';\r\n}\r\n\r\n/**\r\n * Long format for `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction fmtLong(ms) {\r\n  var msAbs = Math.abs(ms);\r\n  if (msAbs >= d) {\r\n    return plural(ms, msAbs, d, 'day');\r\n  }\r\n  if (msAbs >= h) {\r\n    return plural(ms, msAbs, h, 'hour');\r\n  }\r\n  if (msAbs >= m) {\r\n    return plural(ms, msAbs, m, 'minute');\r\n  }\r\n  if (msAbs >= s) {\r\n    return plural(ms, msAbs, s, 'second');\r\n  }\r\n  return ms + ' ms';\r\n}\r\n\r\n/**\r\n * Pluralization helper.\r\n */\r\n\r\nfunction plural(ms, msAbs, n, name) {\r\n  var isPlural = msAbs >= n * 1.5;\r\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\r\n}\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/socket.io-parser/node_modules/ms/index.js?");

/***/ }),

/***/ "./server/public/titlescene/TitleScene.ts":
/*!************************************************!*\
  !*** ./server/public/titlescene/TitleScene.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TitleScene = void 0;\nvar TitleScene = /** @class */ (function () {\n    function TitleScene() {\n        var _this = this;\n        // HTML要素の取得\n        this._buttonElement = document.getElementById('start');\n        this._matchingText = document.getElementById('matchingText');\n        this._matchedMordal = document.querySelector('.matched');\n        // クリックイベントのリスナーを登録\n        this._buttonElement.addEventListener('click', function (event) {\n            //ボタンがクリックされたらボタンが消える\n            _this._buttonElement.className = \"hidden\";\n            //マッチングを開始する\n            _this._matchingText.style.display = 'block';\n        });\n    }\n    Object.defineProperty(TitleScene.prototype, \"StartButton\", {\n        /**\n         * スタートボタンのオブジェクトを返す\n         */\n        get: function () {\n            return this._buttonElement;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * 画面を描写するかを切り替える\n     */\n    TitleScene.prototype.Display = function (display) {\n        //if (this._buttonElement && this._matchingText) {\n        if (this._buttonElement) {\n            if (!display) {\n                // display = falseはすべて非表示にする\n                this._buttonElement.style.visibility = \"hidden\";\n                this._matchingText.style.visibility = \"hidden\";\n                this._matchedMordal.style.visibility = \"hidden\";\n            }\n            else {\n            }\n        }\n    };\n    /**\n     * マッチングしたかどうかの結果を受け取る\n     */\n    TitleScene.prototype.Matched = function (matched) {\n        if (this._buttonElement && this._matchingText) {\n            console.log(matched);\n            if (!matched) {\n                // マッチング結果に基づいて画像ボタンを再描写\n                this._buttonElement.className = \"start\";\n                this._matchingText.style.display = 'none';\n            }\n            else {\n                console.log(\"hoge\");\n                this._buttonElement.style.visibility = \"hidden\";\n                this._matchingText.style.visibility = \"hidden\";\n                this._matchedMordal.style.visibility = \"visible\";\n            }\n        }\n    };\n    TitleScene.prototype.ChangePage = function (url) {\n        window.location.href = url;\n    };\n    return TitleScene;\n}());\nexports.TitleScene = TitleScene;\n\n\n//# sourceURL=webpack://watermelon-io/./server/public/titlescene/TitleScene.ts?");

/***/ }),

/***/ "./server/public/titlescene/index.ts":
/*!*******************************************!*\
  !*** ./server/public/titlescene/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar TitleScene_1 = __webpack_require__(/*! ./TitleScene */ \"./server/public/titlescene/TitleScene.ts\");\nvar socket_io_client_1 = __webpack_require__(/*! socket.io-client */ \"./node_modules/socket.io-client/build/cjs/index.js\");\nwindow.onload = function () {\n    var socket = (0, socket_io_client_1.io)();\n    var TIMEOUT = 10000;\n    var cliantId = \"\";\n    var pairID = \"\";\n    var TITLE_SCENE = new TitleScene_1.TitleScene();\n    socket.on('assignId', function (receiveID) {\n        console.log(\"\\u30AF\\u30E9\\u30A4\\u30A2\\u30F3\\u30C8ID\\u304C\\u5272\\u308A\\u5F53\\u3066\\u3089\\u308C\\u307E\\u3057\\u305F: \".concat(receiveID));\n        cliantId = receiveID;\n    });\n    // タイトル画面の表示\n    TITLE_SCENE.Display(true);\n    TITLE_SCENE.StartButton.addEventListener('click', function (event) {\n        console.log(\"ボタンがクリックされました\");\n        socket.emit('matchingRequest');\n        //数秒間たってもマッチングしなかったらタイムアウト\n        setTimeout(function () {\n            if (pairID === \"\") {\n                TITLE_SCENE.Matched(false);\n                socket.emit('matchingTimeout');\n            }\n        }, TIMEOUT);\n    });\n    socket.on('matchFound', function (pairIDs, isParent) {\n        console.log(\"\\u30AF\\u30E9\\u30A4\\u30A2\\u30F3\\u30C8 \".concat(pairIDs[0], \" \\u3068 \").concat(pairIDs[1], \" \\u304C\\u30DE\\u30C3\\u30C1\\u3057\\u307E\\u3057\\u305F\"));\n        //cliantIdと等しくないものがpairID\n        if (cliantId === pairIDs[0])\n            pairID = pairIDs[1];\n        else\n            pairID = pairIDs[0];\n        //親か子かをログに出力\n        if (isParent)\n            console.log(\"\\u3042\\u306A\\u305F\\u306F\\u89AA\\u3067\\u3059\");\n        //マッチングしたことを伝えるモーダルを表示\n        TITLE_SCENE.Matched(true);\n        //数秒したらページ切り替え\n        setTimeout(function () {\n            TITLE_SCENE.ChangePage(\"/gamescene?you=${cliantId}&pair=${pairID}&parent=${isParent}\");\n        }, 3000);\n    });\n};\n\n\n//# sourceURL=webpack://watermelon-io/./server/public/titlescene/index.ts?");

/***/ }),

/***/ "./node_modules/engine.io-client/build/cjs/contrib/has-cors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/engine.io-client/build/cjs/contrib/has-cors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.hasCORS = void 0;\r\n// imported from https://github.com/component/has-cors\r\nlet value = false;\r\ntry {\r\n    value = typeof XMLHttpRequest !== 'undefined' &&\r\n        'withCredentials' in new XMLHttpRequest();\r\n}\r\ncatch (err) {\r\n    // if XMLHttp support is disabled in IE then it will throw\r\n    // when trying to create\r\n}\r\nexports.hasCORS = value;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/build/cjs/contrib/has-cors.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/build/cjs/contrib/parseqs.js":
/*!********************************************************************!*\
  !*** ./node_modules/engine.io-client/build/cjs/contrib/parseqs.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\n// imported from https://github.com/galkn/querystring\r\n/**\r\n * Compiles a querystring\r\n * Returns string representation of the object\r\n *\r\n * @param {Object}\r\n * @api private\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.decode = exports.encode = void 0;\r\nfunction encode(obj) {\r\n    let str = '';\r\n    for (let i in obj) {\r\n        if (obj.hasOwnProperty(i)) {\r\n            if (str.length)\r\n                str += '&';\r\n            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\r\n        }\r\n    }\r\n    return str;\r\n}\r\nexports.encode = encode;\r\n/**\r\n * Parses a simple querystring into an object\r\n *\r\n * @param {String} qs\r\n * @api private\r\n */\r\nfunction decode(qs) {\r\n    let qry = {};\r\n    let pairs = qs.split('&');\r\n    for (let i = 0, l = pairs.length; i < l; i++) {\r\n        let pair = pairs[i].split('=');\r\n        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\r\n    }\r\n    return qry;\r\n}\r\nexports.decode = decode;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/build/cjs/contrib/parseqs.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/build/cjs/contrib/parseuri.js":
/*!*********************************************************************!*\
  !*** ./node_modules/engine.io-client/build/cjs/contrib/parseuri.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.parse = void 0;\r\n// imported from https://github.com/galkn/parseuri\r\n/**\r\n * Parses a URI\r\n *\r\n * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.\r\n *\r\n * See:\r\n * - https://developer.mozilla.org/en-US/docs/Web/API/URL\r\n * - https://caniuse.com/url\r\n * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B\r\n *\r\n * History of the parse() method:\r\n * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c\r\n * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3\r\n * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242\r\n *\r\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\r\n * @api private\r\n */\r\nconst re = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\r\nconst parts = [\r\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\r\n];\r\nfunction parse(str) {\r\n    if (str.length > 2000) {\r\n        throw \"URI too long\";\r\n    }\r\n    const src = str, b = str.indexOf('['), e = str.indexOf(']');\r\n    if (b != -1 && e != -1) {\r\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\r\n    }\r\n    let m = re.exec(str || ''), uri = {}, i = 14;\r\n    while (i--) {\r\n        uri[parts[i]] = m[i] || '';\r\n    }\r\n    if (b != -1 && e != -1) {\r\n        uri.source = src;\r\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\r\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\r\n        uri.ipv6uri = true;\r\n    }\r\n    uri.pathNames = pathNames(uri, uri['path']);\r\n    uri.queryKey = queryKey(uri, uri['query']);\r\n    return uri;\r\n}\r\nexports.parse = parse;\r\nfunction pathNames(obj, path) {\r\n    const regx = /\\/{2,9}/g, names = path.replace(regx, \"/\").split(\"/\");\r\n    if (path.slice(0, 1) == '/' || path.length === 0) {\r\n        names.splice(0, 1);\r\n    }\r\n    if (path.slice(-1) == '/') {\r\n        names.splice(names.length - 1, 1);\r\n    }\r\n    return names;\r\n}\r\nfunction queryKey(uri, query) {\r\n    const data = {};\r\n    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\r\n        if ($1) {\r\n            data[$1] = $2;\r\n        }\r\n    });\r\n    return data;\r\n}\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/build/cjs/contrib/parseuri.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/build/cjs/contrib/yeast.js":
/*!******************************************************************!*\
  !*** ./node_modules/engine.io-client/build/cjs/contrib/yeast.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("// imported from https://github.com/unshiftio/yeast\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.yeast = exports.decode = exports.encode = void 0;\r\nconst alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''), length = 64, map = {};\r\nlet seed = 0, i = 0, prev;\r\n/**\r\n * Return a string representing the specified number.\r\n *\r\n * @param {Number} num The number to convert.\r\n * @returns {String} The string representation of the number.\r\n * @api public\r\n */\r\nfunction encode(num) {\r\n    let encoded = '';\r\n    do {\r\n        encoded = alphabet[num % length] + encoded;\r\n        num = Math.floor(num / length);\r\n    } while (num > 0);\r\n    return encoded;\r\n}\r\nexports.encode = encode;\r\n/**\r\n * Return the integer value specified by the given string.\r\n *\r\n * @param {String} str The string to convert.\r\n * @returns {Number} The integer value represented by the string.\r\n * @api public\r\n */\r\nfunction decode(str) {\r\n    let decoded = 0;\r\n    for (i = 0; i < str.length; i++) {\r\n        decoded = decoded * length + map[str.charAt(i)];\r\n    }\r\n    return decoded;\r\n}\r\nexports.decode = decode;\r\n/**\r\n * Yeast: A tiny growing id generator.\r\n *\r\n * @returns {String} A unique id.\r\n * @api public\r\n */\r\nfunction yeast() {\r\n    const now = encode(+new Date());\r\n    if (now !== prev)\r\n        return seed = 0, prev = now;\r\n    return now + '.' + encode(seed++);\r\n}\r\nexports.yeast = yeast;\r\n//\r\n// Map each character to its index.\r\n//\r\nfor (; i < length; i++)\r\n    map[alphabet[i]] = i;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/build/cjs/contrib/yeast.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/build/cjs/globalThis.browser.js":
/*!***********************************************************************!*\
  !*** ./node_modules/engine.io-client/build/cjs/globalThis.browser.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.globalThisShim = void 0;\r\nexports.globalThisShim = (() => {\r\n    if (typeof self !== \"undefined\") {\r\n        return self;\r\n    }\r\n    else if (typeof window !== \"undefined\") {\r\n        return window;\r\n    }\r\n    else {\r\n        return Function(\"return this\")();\r\n    }\r\n})();\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/build/cjs/globalThis.browser.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/build/cjs/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/engine.io-client/build/cjs/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.nextTick = exports.parse = exports.installTimerFunctions = exports.transports = exports.TransportError = exports.Transport = exports.protocol = exports.Socket = void 0;\r\nconst socket_js_1 = __webpack_require__(/*! ./socket.js */ \"./node_modules/engine.io-client/build/cjs/socket.js\");\r\nObject.defineProperty(exports, \"Socket\", ({ enumerable: true, get: function () { return socket_js_1.Socket; } }));\r\nexports.protocol = socket_js_1.Socket.protocol;\r\nvar transport_js_1 = __webpack_require__(/*! ./transport.js */ \"./node_modules/engine.io-client/build/cjs/transport.js\");\r\nObject.defineProperty(exports, \"Transport\", ({ enumerable: true, get: function () { return transport_js_1.Transport; } }));\r\nObject.defineProperty(exports, \"TransportError\", ({ enumerable: true, get: function () { return transport_js_1.TransportError; } }));\r\nvar index_js_1 = __webpack_require__(/*! ./transports/index.js */ \"./node_modules/engine.io-client/build/cjs/transports/index.js\");\r\nObject.defineProperty(exports, \"transports\", ({ enumerable: true, get: function () { return index_js_1.transports; } }));\r\nvar util_js_1 = __webpack_require__(/*! ./util.js */ \"./node_modules/engine.io-client/build/cjs/util.js\");\r\nObject.defineProperty(exports, \"installTimerFunctions\", ({ enumerable: true, get: function () { return util_js_1.installTimerFunctions; } }));\r\nvar parseuri_js_1 = __webpack_require__(/*! ./contrib/parseuri.js */ \"./node_modules/engine.io-client/build/cjs/contrib/parseuri.js\");\r\nObject.defineProperty(exports, \"parse\", ({ enumerable: true, get: function () { return parseuri_js_1.parse; } }));\r\nvar websocket_constructor_js_1 = __webpack_require__(/*! ./transports/websocket-constructor.js */ \"./node_modules/engine.io-client/build/cjs/transports/websocket-constructor.browser.js\");\r\nObject.defineProperty(exports, \"nextTick\", ({ enumerable: true, get: function () { return websocket_constructor_js_1.nextTick; } }));\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/build/cjs/index.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/build/cjs/socket.js":
/*!***********************************************************!*\
  !*** ./node_modules/engine.io-client/build/cjs/socket.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Socket = void 0;\r\nconst index_js_1 = __webpack_require__(/*! ./transports/index.js */ \"./node_modules/engine.io-client/build/cjs/transports/index.js\");\r\nconst util_js_1 = __webpack_require__(/*! ./util.js */ \"./node_modules/engine.io-client/build/cjs/util.js\");\r\nconst parseqs_js_1 = __webpack_require__(/*! ./contrib/parseqs.js */ \"./node_modules/engine.io-client/build/cjs/contrib/parseqs.js\");\r\nconst parseuri_js_1 = __webpack_require__(/*! ./contrib/parseuri.js */ \"./node_modules/engine.io-client/build/cjs/contrib/parseuri.js\");\r\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/engine.io-client/node_modules/debug/src/browser.js\")); // debug()\r\nconst component_emitter_1 = __webpack_require__(/*! @socket.io/component-emitter */ \"./node_modules/@socket.io/component-emitter/index.mjs\");\r\nconst engine_io_parser_1 = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/build/cjs/index.js\");\r\nconst websocket_constructor_js_1 = __webpack_require__(/*! ./transports/websocket-constructor.js */ \"./node_modules/engine.io-client/build/cjs/transports/websocket-constructor.browser.js\");\r\nconst debug = (0, debug_1.default)(\"engine.io-client:socket\"); // debug()\r\nclass Socket extends component_emitter_1.Emitter {\r\n    /**\r\n     * Socket constructor.\r\n     *\r\n     * @param {String|Object} uri - uri or options\r\n     * @param {Object} opts - options\r\n     */\r\n    constructor(uri, opts = {}) {\r\n        super();\r\n        this.binaryType = websocket_constructor_js_1.defaultBinaryType;\r\n        this.writeBuffer = [];\r\n        if (uri && \"object\" === typeof uri) {\r\n            opts = uri;\r\n            uri = null;\r\n        }\r\n        if (uri) {\r\n            uri = (0, parseuri_js_1.parse)(uri);\r\n            opts.hostname = uri.host;\r\n            opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\r\n            opts.port = uri.port;\r\n            if (uri.query)\r\n                opts.query = uri.query;\r\n        }\r\n        else if (opts.host) {\r\n            opts.hostname = (0, parseuri_js_1.parse)(opts.host).host;\r\n        }\r\n        (0, util_js_1.installTimerFunctions)(this, opts);\r\n        this.secure =\r\n            null != opts.secure\r\n                ? opts.secure\r\n                : typeof location !== \"undefined\" && \"https:\" === location.protocol;\r\n        if (opts.hostname && !opts.port) {\r\n            // if no port is specified manually, use the protocol default\r\n            opts.port = this.secure ? \"443\" : \"80\";\r\n        }\r\n        this.hostname =\r\n            opts.hostname ||\r\n                (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\r\n        this.port =\r\n            opts.port ||\r\n                (typeof location !== \"undefined\" && location.port\r\n                    ? location.port\r\n                    : this.secure\r\n                        ? \"443\"\r\n                        : \"80\");\r\n        this.transports = opts.transports || [\r\n            \"polling\",\r\n            \"websocket\",\r\n            \"webtransport\",\r\n        ];\r\n        this.writeBuffer = [];\r\n        this.prevBufferLen = 0;\r\n        this.opts = Object.assign({\r\n            path: \"/engine.io\",\r\n            agent: false,\r\n            withCredentials: false,\r\n            upgrade: true,\r\n            timestampParam: \"t\",\r\n            rememberUpgrade: false,\r\n            addTrailingSlash: true,\r\n            rejectUnauthorized: true,\r\n            perMessageDeflate: {\r\n                threshold: 1024,\r\n            },\r\n            transportOptions: {},\r\n            closeOnBeforeunload: false,\r\n        }, opts);\r\n        this.opts.path =\r\n            this.opts.path.replace(/\\/$/, \"\") +\r\n                (this.opts.addTrailingSlash ? \"/\" : \"\");\r\n        if (typeof this.opts.query === \"string\") {\r\n            this.opts.query = (0, parseqs_js_1.decode)(this.opts.query);\r\n        }\r\n        // set on handshake\r\n        this.id = null;\r\n        this.upgrades = null;\r\n        this.pingInterval = null;\r\n        this.pingTimeout = null;\r\n        // set on heartbeat\r\n        this.pingTimeoutTimer = null;\r\n        if (typeof addEventListener === \"function\") {\r\n            if (this.opts.closeOnBeforeunload) {\r\n                // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\r\n                // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\r\n                // closed/reloaded)\r\n                this.beforeunloadEventListener = () => {\r\n                    if (this.transport) {\r\n                        // silently close the transport\r\n                        this.transport.removeAllListeners();\r\n                        this.transport.close();\r\n                    }\r\n                };\r\n                addEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\r\n            }\r\n            if (this.hostname !== \"localhost\") {\r\n                this.offlineEventListener = () => {\r\n                    this.onClose(\"transport close\", {\r\n                        description: \"network connection lost\",\r\n                    });\r\n                };\r\n                addEventListener(\"offline\", this.offlineEventListener, false);\r\n            }\r\n        }\r\n        this.open();\r\n    }\r\n    /**\r\n     * Creates transport of the given type.\r\n     *\r\n     * @param {String} name - transport name\r\n     * @return {Transport}\r\n     * @private\r\n     */\r\n    createTransport(name) {\r\n        debug('creating transport \"%s\"', name);\r\n        const query = Object.assign({}, this.opts.query);\r\n        // append engine.io protocol identifier\r\n        query.EIO = engine_io_parser_1.protocol;\r\n        // transport name\r\n        query.transport = name;\r\n        // session id if we already have one\r\n        if (this.id)\r\n            query.sid = this.id;\r\n        const opts = Object.assign({}, this.opts, {\r\n            query,\r\n            socket: this,\r\n            hostname: this.hostname,\r\n            secure: this.secure,\r\n            port: this.port,\r\n        }, this.opts.transportOptions[name]);\r\n        debug(\"options: %j\", opts);\r\n        return new index_js_1.transports[name](opts);\r\n    }\r\n    /**\r\n     * Initializes transport to use and starts probe.\r\n     *\r\n     * @private\r\n     */\r\n    open() {\r\n        let transport;\r\n        if (this.opts.rememberUpgrade &&\r\n            Socket.priorWebsocketSuccess &&\r\n            this.transports.indexOf(\"websocket\") !== -1) {\r\n            transport = \"websocket\";\r\n        }\r\n        else if (0 === this.transports.length) {\r\n            // Emit error on next tick so it can be listened to\r\n            this.setTimeoutFn(() => {\r\n                this.emitReserved(\"error\", \"No transports available\");\r\n            }, 0);\r\n            return;\r\n        }\r\n        else {\r\n            transport = this.transports[0];\r\n        }\r\n        this.readyState = \"opening\";\r\n        // Retry with the next transport if the transport is disabled (jsonp: false)\r\n        try {\r\n            transport = this.createTransport(transport);\r\n        }\r\n        catch (e) {\r\n            debug(\"error while creating transport: %s\", e);\r\n            this.transports.shift();\r\n            this.open();\r\n            return;\r\n        }\r\n        transport.open();\r\n        this.setTransport(transport);\r\n    }\r\n    /**\r\n     * Sets the current transport. Disables the existing one (if any).\r\n     *\r\n     * @private\r\n     */\r\n    setTransport(transport) {\r\n        debug(\"setting transport %s\", transport.name);\r\n        if (this.transport) {\r\n            debug(\"clearing existing transport %s\", this.transport.name);\r\n            this.transport.removeAllListeners();\r\n        }\r\n        // set up transport\r\n        this.transport = transport;\r\n        // set up transport listeners\r\n        transport\r\n            .on(\"drain\", this.onDrain.bind(this))\r\n            .on(\"packet\", this.onPacket.bind(this))\r\n            .on(\"error\", this.onError.bind(this))\r\n            .on(\"close\", (reason) => this.onClose(\"transport close\", reason));\r\n    }\r\n    /**\r\n     * Probes a transport.\r\n     *\r\n     * @param {String} name - transport name\r\n     * @private\r\n     */\r\n    probe(name) {\r\n        debug('probing transport \"%s\"', name);\r\n        let transport = this.createTransport(name);\r\n        let failed = false;\r\n        Socket.priorWebsocketSuccess = false;\r\n        const onTransportOpen = () => {\r\n            if (failed)\r\n                return;\r\n            debug('probe transport \"%s\" opened', name);\r\n            transport.send([{ type: \"ping\", data: \"probe\" }]);\r\n            transport.once(\"packet\", (msg) => {\r\n                if (failed)\r\n                    return;\r\n                if (\"pong\" === msg.type && \"probe\" === msg.data) {\r\n                    debug('probe transport \"%s\" pong', name);\r\n                    this.upgrading = true;\r\n                    this.emitReserved(\"upgrading\", transport);\r\n                    if (!transport)\r\n                        return;\r\n                    Socket.priorWebsocketSuccess = \"websocket\" === transport.name;\r\n                    debug('pausing current transport \"%s\"', this.transport.name);\r\n                    this.transport.pause(() => {\r\n                        if (failed)\r\n                            return;\r\n                        if (\"closed\" === this.readyState)\r\n                            return;\r\n                        debug(\"changing transport and sending upgrade packet\");\r\n                        cleanup();\r\n                        this.setTransport(transport);\r\n                        transport.send([{ type: \"upgrade\" }]);\r\n                        this.emitReserved(\"upgrade\", transport);\r\n                        transport = null;\r\n                        this.upgrading = false;\r\n                        this.flush();\r\n                    });\r\n                }\r\n                else {\r\n                    debug('probe transport \"%s\" failed', name);\r\n                    const err = new Error(\"probe error\");\r\n                    // @ts-ignore\r\n                    err.transport = transport.name;\r\n                    this.emitReserved(\"upgradeError\", err);\r\n                }\r\n            });\r\n        };\r\n        function freezeTransport() {\r\n            if (failed)\r\n                return;\r\n            // Any callback called by transport should be ignored since now\r\n            failed = true;\r\n            cleanup();\r\n            transport.close();\r\n            transport = null;\r\n        }\r\n        // Handle any error that happens while probing\r\n        const onerror = (err) => {\r\n            const error = new Error(\"probe error: \" + err);\r\n            // @ts-ignore\r\n            error.transport = transport.name;\r\n            freezeTransport();\r\n            debug('probe transport \"%s\" failed because of error: %s', name, err);\r\n            this.emitReserved(\"upgradeError\", error);\r\n        };\r\n        function onTransportClose() {\r\n            onerror(\"transport closed\");\r\n        }\r\n        // When the socket is closed while we're probing\r\n        function onclose() {\r\n            onerror(\"socket closed\");\r\n        }\r\n        // When the socket is upgraded while we're probing\r\n        function onupgrade(to) {\r\n            if (transport && to.name !== transport.name) {\r\n                debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\r\n                freezeTransport();\r\n            }\r\n        }\r\n        // Remove all listeners on the transport and on self\r\n        const cleanup = () => {\r\n            transport.removeListener(\"open\", onTransportOpen);\r\n            transport.removeListener(\"error\", onerror);\r\n            transport.removeListener(\"close\", onTransportClose);\r\n            this.off(\"close\", onclose);\r\n            this.off(\"upgrading\", onupgrade);\r\n        };\r\n        transport.once(\"open\", onTransportOpen);\r\n        transport.once(\"error\", onerror);\r\n        transport.once(\"close\", onTransportClose);\r\n        this.once(\"close\", onclose);\r\n        this.once(\"upgrading\", onupgrade);\r\n        if (this.upgrades.indexOf(\"webtransport\") !== -1 &&\r\n            name !== \"webtransport\") {\r\n            // favor WebTransport\r\n            this.setTimeoutFn(() => {\r\n                if (!failed) {\r\n                    transport.open();\r\n                }\r\n            }, 200);\r\n        }\r\n        else {\r\n            transport.open();\r\n        }\r\n    }\r\n    /**\r\n     * Called when connection is deemed open.\r\n     *\r\n     * @private\r\n     */\r\n    onOpen() {\r\n        debug(\"socket open\");\r\n        this.readyState = \"open\";\r\n        Socket.priorWebsocketSuccess = \"websocket\" === this.transport.name;\r\n        this.emitReserved(\"open\");\r\n        this.flush();\r\n        // we check for `readyState` in case an `open`\r\n        // listener already closed the socket\r\n        if (\"open\" === this.readyState && this.opts.upgrade) {\r\n            debug(\"starting upgrade probes\");\r\n            let i = 0;\r\n            const l = this.upgrades.length;\r\n            for (; i < l; i++) {\r\n                this.probe(this.upgrades[i]);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Handles a packet.\r\n     *\r\n     * @private\r\n     */\r\n    onPacket(packet) {\r\n        if (\"opening\" === this.readyState ||\r\n            \"open\" === this.readyState ||\r\n            \"closing\" === this.readyState) {\r\n            debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\r\n            this.emitReserved(\"packet\", packet);\r\n            // Socket is live - any packet counts\r\n            this.emitReserved(\"heartbeat\");\r\n            this.resetPingTimeout();\r\n            switch (packet.type) {\r\n                case \"open\":\r\n                    this.onHandshake(JSON.parse(packet.data));\r\n                    break;\r\n                case \"ping\":\r\n                    this.sendPacket(\"pong\");\r\n                    this.emitReserved(\"ping\");\r\n                    this.emitReserved(\"pong\");\r\n                    break;\r\n                case \"error\":\r\n                    const err = new Error(\"server error\");\r\n                    // @ts-ignore\r\n                    err.code = packet.data;\r\n                    this.onError(err);\r\n                    break;\r\n                case \"message\":\r\n                    this.emitReserved(\"data\", packet.data);\r\n                    this.emitReserved(\"message\", packet.data);\r\n                    break;\r\n            }\r\n        }\r\n        else {\r\n            debug('packet received with socket readyState \"%s\"', this.readyState);\r\n        }\r\n    }\r\n    /**\r\n     * Called upon handshake completion.\r\n     *\r\n     * @param {Object} data - handshake obj\r\n     * @private\r\n     */\r\n    onHandshake(data) {\r\n        this.emitReserved(\"handshake\", data);\r\n        this.id = data.sid;\r\n        this.transport.query.sid = data.sid;\r\n        this.upgrades = this.filterUpgrades(data.upgrades);\r\n        this.pingInterval = data.pingInterval;\r\n        this.pingTimeout = data.pingTimeout;\r\n        this.maxPayload = data.maxPayload;\r\n        this.onOpen();\r\n        // In case open handler closes socket\r\n        if (\"closed\" === this.readyState)\r\n            return;\r\n        this.resetPingTimeout();\r\n    }\r\n    /**\r\n     * Sets and resets ping timeout timer based on server pings.\r\n     *\r\n     * @private\r\n     */\r\n    resetPingTimeout() {\r\n        this.clearTimeoutFn(this.pingTimeoutTimer);\r\n        this.pingTimeoutTimer = this.setTimeoutFn(() => {\r\n            this.onClose(\"ping timeout\");\r\n        }, this.pingInterval + this.pingTimeout);\r\n        if (this.opts.autoUnref) {\r\n            this.pingTimeoutTimer.unref();\r\n        }\r\n    }\r\n    /**\r\n     * Called on `drain` event\r\n     *\r\n     * @private\r\n     */\r\n    onDrain() {\r\n        this.writeBuffer.splice(0, this.prevBufferLen);\r\n        // setting prevBufferLen = 0 is very important\r\n        // for example, when upgrading, upgrade packet is sent over,\r\n        // and a nonzero prevBufferLen could cause problems on `drain`\r\n        this.prevBufferLen = 0;\r\n        if (0 === this.writeBuffer.length) {\r\n            this.emitReserved(\"drain\");\r\n        }\r\n        else {\r\n            this.flush();\r\n        }\r\n    }\r\n    /**\r\n     * Flush write buffers.\r\n     *\r\n     * @private\r\n     */\r\n    flush() {\r\n        if (\"closed\" !== this.readyState &&\r\n            this.transport.writable &&\r\n            !this.upgrading &&\r\n            this.writeBuffer.length) {\r\n            const packets = this.getWritablePackets();\r\n            debug(\"flushing %d packets in socket\", packets.length);\r\n            this.transport.send(packets);\r\n            // keep track of current length of writeBuffer\r\n            // splice writeBuffer and callbackBuffer on `drain`\r\n            this.prevBufferLen = packets.length;\r\n            this.emitReserved(\"flush\");\r\n        }\r\n    }\r\n    /**\r\n     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP\r\n     * long-polling)\r\n     *\r\n     * @private\r\n     */\r\n    getWritablePackets() {\r\n        const shouldCheckPayloadSize = this.maxPayload &&\r\n            this.transport.name === \"polling\" &&\r\n            this.writeBuffer.length > 1;\r\n        if (!shouldCheckPayloadSize) {\r\n            return this.writeBuffer;\r\n        }\r\n        let payloadSize = 1; // first packet type\r\n        for (let i = 0; i < this.writeBuffer.length; i++) {\r\n            const data = this.writeBuffer[i].data;\r\n            if (data) {\r\n                payloadSize += (0, util_js_1.byteLength)(data);\r\n            }\r\n            if (i > 0 && payloadSize > this.maxPayload) {\r\n                debug(\"only send %d out of %d packets\", i, this.writeBuffer.length);\r\n                return this.writeBuffer.slice(0, i);\r\n            }\r\n            payloadSize += 2; // separator + packet type\r\n        }\r\n        debug(\"payload size is %d (max: %d)\", payloadSize, this.maxPayload);\r\n        return this.writeBuffer;\r\n    }\r\n    /**\r\n     * Sends a message.\r\n     *\r\n     * @param {String} msg - message.\r\n     * @param {Object} options.\r\n     * @param {Function} callback function.\r\n     * @return {Socket} for chaining.\r\n     */\r\n    write(msg, options, fn) {\r\n        this.sendPacket(\"message\", msg, options, fn);\r\n        return this;\r\n    }\r\n    send(msg, options, fn) {\r\n        this.sendPacket(\"message\", msg, options, fn);\r\n        return this;\r\n    }\r\n    /**\r\n     * Sends a packet.\r\n     *\r\n     * @param {String} type: packet type.\r\n     * @param {String} data.\r\n     * @param {Object} options.\r\n     * @param {Function} fn - callback function.\r\n     * @private\r\n     */\r\n    sendPacket(type, data, options, fn) {\r\n        if (\"function\" === typeof data) {\r\n            fn = data;\r\n            data = undefined;\r\n        }\r\n        if (\"function\" === typeof options) {\r\n            fn = options;\r\n            options = null;\r\n        }\r\n        if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\r\n            return;\r\n        }\r\n        options = options || {};\r\n        options.compress = false !== options.compress;\r\n        const packet = {\r\n            type: type,\r\n            data: data,\r\n            options: options,\r\n        };\r\n        this.emitReserved(\"packetCreate\", packet);\r\n        this.writeBuffer.push(packet);\r\n        if (fn)\r\n            this.once(\"flush\", fn);\r\n        this.flush();\r\n    }\r\n    /**\r\n     * Closes the connection.\r\n     */\r\n    close() {\r\n        const close = () => {\r\n            this.onClose(\"forced close\");\r\n            debug(\"socket closing - telling transport to close\");\r\n            this.transport.close();\r\n        };\r\n        const cleanupAndClose = () => {\r\n            this.off(\"upgrade\", cleanupAndClose);\r\n            this.off(\"upgradeError\", cleanupAndClose);\r\n            close();\r\n        };\r\n        const waitForUpgrade = () => {\r\n            // wait for upgrade to finish since we can't send packets while pausing a transport\r\n            this.once(\"upgrade\", cleanupAndClose);\r\n            this.once(\"upgradeError\", cleanupAndClose);\r\n        };\r\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\r\n            this.readyState = \"closing\";\r\n            if (this.writeBuffer.length) {\r\n                this.once(\"drain\", () => {\r\n                    if (this.upgrading) {\r\n                        waitForUpgrade();\r\n                    }\r\n                    else {\r\n                        close();\r\n                    }\r\n                });\r\n            }\r\n            else if (this.upgrading) {\r\n                waitForUpgrade();\r\n            }\r\n            else {\r\n                close();\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Called upon transport error\r\n     *\r\n     * @private\r\n     */\r\n    onError(err) {\r\n        debug(\"socket error %j\", err);\r\n        Socket.priorWebsocketSuccess = false;\r\n        this.emitReserved(\"error\", err);\r\n        this.onClose(\"transport error\", err);\r\n    }\r\n    /**\r\n     * Called upon transport close.\r\n     *\r\n     * @private\r\n     */\r\n    onClose(reason, description) {\r\n        if (\"opening\" === this.readyState ||\r\n            \"open\" === this.readyState ||\r\n            \"closing\" === this.readyState) {\r\n            debug('socket close with reason: \"%s\"', reason);\r\n            // clear timers\r\n            this.clearTimeoutFn(this.pingTimeoutTimer);\r\n            // stop event from firing again for transport\r\n            this.transport.removeAllListeners(\"close\");\r\n            // ensure transport won't stay open\r\n            this.transport.close();\r\n            // ignore further transport communication\r\n            this.transport.removeAllListeners();\r\n            if (typeof removeEventListener === \"function\") {\r\n                removeEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\r\n                removeEventListener(\"offline\", this.offlineEventListener, false);\r\n            }\r\n            // set ready state\r\n            this.readyState = \"closed\";\r\n            // clear session id\r\n            this.id = null;\r\n            // emit close event\r\n            this.emitReserved(\"close\", reason, description);\r\n            // clean buffers after, so users can still\r\n            // grab the buffers on `close` event\r\n            this.writeBuffer = [];\r\n            this.prevBufferLen = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Filters upgrades, returning only those matching client transports.\r\n     *\r\n     * @param {Array} upgrades - server upgrades\r\n     * @private\r\n     */\r\n    filterUpgrades(upgrades) {\r\n        const filteredUpgrades = [];\r\n        let i = 0;\r\n        const j = upgrades.length;\r\n        for (; i < j; i++) {\r\n            if (~this.transports.indexOf(upgrades[i]))\r\n                filteredUpgrades.push(upgrades[i]);\r\n        }\r\n        return filteredUpgrades;\r\n    }\r\n}\r\nexports.Socket = Socket;\r\nSocket.protocol = engine_io_parser_1.protocol;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/build/cjs/socket.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/build/cjs/transport.js":
/*!**************************************************************!*\
  !*** ./node_modules/engine.io-client/build/cjs/transport.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Transport = exports.TransportError = void 0;\r\nconst engine_io_parser_1 = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/build/cjs/index.js\");\r\nconst component_emitter_1 = __webpack_require__(/*! @socket.io/component-emitter */ \"./node_modules/@socket.io/component-emitter/index.mjs\");\r\nconst util_js_1 = __webpack_require__(/*! ./util.js */ \"./node_modules/engine.io-client/build/cjs/util.js\");\r\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/engine.io-client/node_modules/debug/src/browser.js\")); // debug()\r\nconst parseqs_js_1 = __webpack_require__(/*! ./contrib/parseqs.js */ \"./node_modules/engine.io-client/build/cjs/contrib/parseqs.js\");\r\nconst debug = (0, debug_1.default)(\"engine.io-client:transport\"); // debug()\r\nclass TransportError extends Error {\r\n    constructor(reason, description, context) {\r\n        super(reason);\r\n        this.description = description;\r\n        this.context = context;\r\n        this.type = \"TransportError\";\r\n    }\r\n}\r\nexports.TransportError = TransportError;\r\nclass Transport extends component_emitter_1.Emitter {\r\n    /**\r\n     * Transport abstract constructor.\r\n     *\r\n     * @param {Object} opts - options\r\n     * @protected\r\n     */\r\n    constructor(opts) {\r\n        super();\r\n        this.writable = false;\r\n        (0, util_js_1.installTimerFunctions)(this, opts);\r\n        this.opts = opts;\r\n        this.query = opts.query;\r\n        this.socket = opts.socket;\r\n    }\r\n    /**\r\n     * Emits an error.\r\n     *\r\n     * @param {String} reason\r\n     * @param description\r\n     * @param context - the error context\r\n     * @return {Transport} for chaining\r\n     * @protected\r\n     */\r\n    onError(reason, description, context) {\r\n        super.emitReserved(\"error\", new TransportError(reason, description, context));\r\n        return this;\r\n    }\r\n    /**\r\n     * Opens the transport.\r\n     */\r\n    open() {\r\n        this.readyState = \"opening\";\r\n        this.doOpen();\r\n        return this;\r\n    }\r\n    /**\r\n     * Closes the transport.\r\n     */\r\n    close() {\r\n        if (this.readyState === \"opening\" || this.readyState === \"open\") {\r\n            this.doClose();\r\n            this.onClose();\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Sends multiple packets.\r\n     *\r\n     * @param {Array} packets\r\n     */\r\n    send(packets) {\r\n        if (this.readyState === \"open\") {\r\n            this.write(packets);\r\n        }\r\n        else {\r\n            // this might happen if the transport was silently closed in the beforeunload event handler\r\n            debug(\"transport is not open, discarding packets\");\r\n        }\r\n    }\r\n    /**\r\n     * Called upon open\r\n     *\r\n     * @protected\r\n     */\r\n    onOpen() {\r\n        this.readyState = \"open\";\r\n        this.writable = true;\r\n        super.emitReserved(\"open\");\r\n    }\r\n    /**\r\n     * Called with data.\r\n     *\r\n     * @param {String} data\r\n     * @protected\r\n     */\r\n    onData(data) {\r\n        const packet = (0, engine_io_parser_1.decodePacket)(data, this.socket.binaryType);\r\n        this.onPacket(packet);\r\n    }\r\n    /**\r\n     * Called with a decoded packet.\r\n     *\r\n     * @protected\r\n     */\r\n    onPacket(packet) {\r\n        super.emitReserved(\"packet\", packet);\r\n    }\r\n    /**\r\n     * Called upon close.\r\n     *\r\n     * @protected\r\n     */\r\n    onClose(details) {\r\n        this.readyState = \"closed\";\r\n        super.emitReserved(\"close\", details);\r\n    }\r\n    /**\r\n     * Pauses the transport, in order not to lose packets during an upgrade.\r\n     *\r\n     * @param onPause\r\n     */\r\n    pause(onPause) { }\r\n    createUri(schema, query = {}) {\r\n        return (schema +\r\n            \"://\" +\r\n            this._hostname() +\r\n            this._port() +\r\n            this.opts.path +\r\n            this._query(query));\r\n    }\r\n    _hostname() {\r\n        const hostname = this.opts.hostname;\r\n        return hostname.indexOf(\":\") === -1 ? hostname : \"[\" + hostname + \"]\";\r\n    }\r\n    _port() {\r\n        if (this.opts.port &&\r\n            ((this.opts.secure && Number(this.opts.port !== 443)) ||\r\n                (!this.opts.secure && Number(this.opts.port) !== 80))) {\r\n            return \":\" + this.opts.port;\r\n        }\r\n        else {\r\n            return \"\";\r\n        }\r\n    }\r\n    _query(query) {\r\n        const encodedQuery = (0, parseqs_js_1.encode)(query);\r\n        return encodedQuery.length ? \"?\" + encodedQuery : \"\";\r\n    }\r\n}\r\nexports.Transport = Transport;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/build/cjs/transport.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/build/cjs/transports/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/engine.io-client/build/cjs/transports/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.transports = void 0;\r\nconst polling_js_1 = __webpack_require__(/*! ./polling.js */ \"./node_modules/engine.io-client/build/cjs/transports/polling.js\");\r\nconst websocket_js_1 = __webpack_require__(/*! ./websocket.js */ \"./node_modules/engine.io-client/build/cjs/transports/websocket.js\");\r\nconst webtransport_js_1 = __webpack_require__(/*! ./webtransport.js */ \"./node_modules/engine.io-client/build/cjs/transports/webtransport.js\");\r\nexports.transports = {\r\n    websocket: websocket_js_1.WS,\r\n    webtransport: webtransport_js_1.WT,\r\n    polling: polling_js_1.Polling,\r\n};\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/build/cjs/transports/index.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/build/cjs/transports/polling.js":
/*!***********************************************************************!*\
  !*** ./node_modules/engine.io-client/build/cjs/transports/polling.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Request = exports.Polling = void 0;\r\nconst transport_js_1 = __webpack_require__(/*! ../transport.js */ \"./node_modules/engine.io-client/build/cjs/transport.js\");\r\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/engine.io-client/node_modules/debug/src/browser.js\")); // debug()\r\nconst yeast_js_1 = __webpack_require__(/*! ../contrib/yeast.js */ \"./node_modules/engine.io-client/build/cjs/contrib/yeast.js\");\r\nconst engine_io_parser_1 = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/build/cjs/index.js\");\r\nconst xmlhttprequest_js_1 = __webpack_require__(/*! ./xmlhttprequest.js */ \"./node_modules/engine.io-client/build/cjs/transports/xmlhttprequest.browser.js\");\r\nconst component_emitter_1 = __webpack_require__(/*! @socket.io/component-emitter */ \"./node_modules/@socket.io/component-emitter/index.mjs\");\r\nconst util_js_1 = __webpack_require__(/*! ../util.js */ \"./node_modules/engine.io-client/build/cjs/util.js\");\r\nconst globalThis_js_1 = __webpack_require__(/*! ../globalThis.js */ \"./node_modules/engine.io-client/build/cjs/globalThis.browser.js\");\r\nconst debug = (0, debug_1.default)(\"engine.io-client:polling\"); // debug()\r\nfunction empty() { }\r\nconst hasXHR2 = (function () {\r\n    const xhr = new xmlhttprequest_js_1.XHR({\r\n        xdomain: false,\r\n    });\r\n    return null != xhr.responseType;\r\n})();\r\nclass Polling extends transport_js_1.Transport {\r\n    /**\r\n     * XHR Polling constructor.\r\n     *\r\n     * @param {Object} opts\r\n     * @package\r\n     */\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.polling = false;\r\n        if (typeof location !== \"undefined\") {\r\n            const isSSL = \"https:\" === location.protocol;\r\n            let port = location.port;\r\n            // some user agents have empty `location.port`\r\n            if (!port) {\r\n                port = isSSL ? \"443\" : \"80\";\r\n            }\r\n            this.xd =\r\n                (typeof location !== \"undefined\" &&\r\n                    opts.hostname !== location.hostname) ||\r\n                    port !== opts.port;\r\n        }\r\n        /**\r\n         * XHR supports binary\r\n         */\r\n        const forceBase64 = opts && opts.forceBase64;\r\n        this.supportsBinary = hasXHR2 && !forceBase64;\r\n        if (this.opts.withCredentials) {\r\n            this.cookieJar = (0, xmlhttprequest_js_1.createCookieJar)();\r\n        }\r\n    }\r\n    get name() {\r\n        return \"polling\";\r\n    }\r\n    /**\r\n     * Opens the socket (triggers polling). We write a PING message to determine\r\n     * when the transport is open.\r\n     *\r\n     * @protected\r\n     */\r\n    doOpen() {\r\n        this.poll();\r\n    }\r\n    /**\r\n     * Pauses polling.\r\n     *\r\n     * @param {Function} onPause - callback upon buffers are flushed and transport is paused\r\n     * @package\r\n     */\r\n    pause(onPause) {\r\n        this.readyState = \"pausing\";\r\n        const pause = () => {\r\n            debug(\"paused\");\r\n            this.readyState = \"paused\";\r\n            onPause();\r\n        };\r\n        if (this.polling || !this.writable) {\r\n            let total = 0;\r\n            if (this.polling) {\r\n                debug(\"we are currently polling - waiting to pause\");\r\n                total++;\r\n                this.once(\"pollComplete\", function () {\r\n                    debug(\"pre-pause polling complete\");\r\n                    --total || pause();\r\n                });\r\n            }\r\n            if (!this.writable) {\r\n                debug(\"we are currently writing - waiting to pause\");\r\n                total++;\r\n                this.once(\"drain\", function () {\r\n                    debug(\"pre-pause writing complete\");\r\n                    --total || pause();\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            pause();\r\n        }\r\n    }\r\n    /**\r\n     * Starts polling cycle.\r\n     *\r\n     * @private\r\n     */\r\n    poll() {\r\n        debug(\"polling\");\r\n        this.polling = true;\r\n        this.doPoll();\r\n        this.emitReserved(\"poll\");\r\n    }\r\n    /**\r\n     * Overloads onData to detect payloads.\r\n     *\r\n     * @protected\r\n     */\r\n    onData(data) {\r\n        debug(\"polling got data %s\", data);\r\n        const callback = (packet) => {\r\n            // if its the first message we consider the transport open\r\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\r\n                this.onOpen();\r\n            }\r\n            // if its a close packet, we close the ongoing requests\r\n            if (\"close\" === packet.type) {\r\n                this.onClose({ description: \"transport closed by the server\" });\r\n                return false;\r\n            }\r\n            // otherwise bypass onData and handle the message\r\n            this.onPacket(packet);\r\n        };\r\n        // decode payload\r\n        (0, engine_io_parser_1.decodePayload)(data, this.socket.binaryType).forEach(callback);\r\n        // if an event did not trigger closing\r\n        if (\"closed\" !== this.readyState) {\r\n            // if we got data we're not polling\r\n            this.polling = false;\r\n            this.emitReserved(\"pollComplete\");\r\n            if (\"open\" === this.readyState) {\r\n                this.poll();\r\n            }\r\n            else {\r\n                debug('ignoring poll - transport state \"%s\"', this.readyState);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * For polling, send a close packet.\r\n     *\r\n     * @protected\r\n     */\r\n    doClose() {\r\n        const close = () => {\r\n            debug(\"writing close packet\");\r\n            this.write([{ type: \"close\" }]);\r\n        };\r\n        if (\"open\" === this.readyState) {\r\n            debug(\"transport open - closing\");\r\n            close();\r\n        }\r\n        else {\r\n            // in case we're trying to close while\r\n            // handshaking is in progress (GH-164)\r\n            debug(\"transport not open - deferring close\");\r\n            this.once(\"open\", close);\r\n        }\r\n    }\r\n    /**\r\n     * Writes a packets payload.\r\n     *\r\n     * @param {Array} packets - data packets\r\n     * @protected\r\n     */\r\n    write(packets) {\r\n        this.writable = false;\r\n        (0, engine_io_parser_1.encodePayload)(packets, (data) => {\r\n            this.doWrite(data, () => {\r\n                this.writable = true;\r\n                this.emitReserved(\"drain\");\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Generates uri for connection.\r\n     *\r\n     * @private\r\n     */\r\n    uri() {\r\n        const schema = this.opts.secure ? \"https\" : \"http\";\r\n        const query = this.query || {};\r\n        // cache busting is forced\r\n        if (false !== this.opts.timestampRequests) {\r\n            query[this.opts.timestampParam] = (0, yeast_js_1.yeast)();\r\n        }\r\n        if (!this.supportsBinary && !query.sid) {\r\n            query.b64 = 1;\r\n        }\r\n        return this.createUri(schema, query);\r\n    }\r\n    /**\r\n     * Creates a request.\r\n     *\r\n     * @param {String} method\r\n     * @private\r\n     */\r\n    request(opts = {}) {\r\n        Object.assign(opts, { xd: this.xd, cookieJar: this.cookieJar }, this.opts);\r\n        return new Request(this.uri(), opts);\r\n    }\r\n    /**\r\n     * Sends data.\r\n     *\r\n     * @param {String} data to send.\r\n     * @param {Function} called upon flush.\r\n     * @private\r\n     */\r\n    doWrite(data, fn) {\r\n        const req = this.request({\r\n            method: \"POST\",\r\n            data: data,\r\n        });\r\n        req.on(\"success\", fn);\r\n        req.on(\"error\", (xhrStatus, context) => {\r\n            this.onError(\"xhr post error\", xhrStatus, context);\r\n        });\r\n    }\r\n    /**\r\n     * Starts a poll cycle.\r\n     *\r\n     * @private\r\n     */\r\n    doPoll() {\r\n        debug(\"xhr poll\");\r\n        const req = this.request();\r\n        req.on(\"data\", this.onData.bind(this));\r\n        req.on(\"error\", (xhrStatus, context) => {\r\n            this.onError(\"xhr poll error\", xhrStatus, context);\r\n        });\r\n        this.pollXhr = req;\r\n    }\r\n}\r\nexports.Polling = Polling;\r\nclass Request extends component_emitter_1.Emitter {\r\n    /**\r\n     * Request constructor\r\n     *\r\n     * @param {Object} options\r\n     * @package\r\n     */\r\n    constructor(uri, opts) {\r\n        super();\r\n        (0, util_js_1.installTimerFunctions)(this, opts);\r\n        this.opts = opts;\r\n        this.method = opts.method || \"GET\";\r\n        this.uri = uri;\r\n        this.data = undefined !== opts.data ? opts.data : null;\r\n        this.create();\r\n    }\r\n    /**\r\n     * Creates the XHR object and sends the request.\r\n     *\r\n     * @private\r\n     */\r\n    create() {\r\n        var _a;\r\n        const opts = (0, util_js_1.pick)(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\r\n        opts.xdomain = !!this.opts.xd;\r\n        const xhr = (this.xhr = new xmlhttprequest_js_1.XHR(opts));\r\n        try {\r\n            debug(\"xhr open %s: %s\", this.method, this.uri);\r\n            xhr.open(this.method, this.uri, true);\r\n            try {\r\n                if (this.opts.extraHeaders) {\r\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\r\n                    for (let i in this.opts.extraHeaders) {\r\n                        if (this.opts.extraHeaders.hasOwnProperty(i)) {\r\n                            xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            catch (e) { }\r\n            if (\"POST\" === this.method) {\r\n                try {\r\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\r\n                }\r\n                catch (e) { }\r\n            }\r\n            try {\r\n                xhr.setRequestHeader(\"Accept\", \"*/*\");\r\n            }\r\n            catch (e) { }\r\n            (_a = this.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);\r\n            // ie6 check\r\n            if (\"withCredentials\" in xhr) {\r\n                xhr.withCredentials = this.opts.withCredentials;\r\n            }\r\n            if (this.opts.requestTimeout) {\r\n                xhr.timeout = this.opts.requestTimeout;\r\n            }\r\n            xhr.onreadystatechange = () => {\r\n                var _a;\r\n                if (xhr.readyState === 3) {\r\n                    (_a = this.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(xhr);\r\n                }\r\n                if (4 !== xhr.readyState)\r\n                    return;\r\n                if (200 === xhr.status || 1223 === xhr.status) {\r\n                    this.onLoad();\r\n                }\r\n                else {\r\n                    // make sure the `error` event handler that's user-set\r\n                    // does not throw in the same tick and gets caught here\r\n                    this.setTimeoutFn(() => {\r\n                        this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\r\n                    }, 0);\r\n                }\r\n            };\r\n            debug(\"xhr data %s\", this.data);\r\n            xhr.send(this.data);\r\n        }\r\n        catch (e) {\r\n            // Need to defer since .create() is called directly from the constructor\r\n            // and thus the 'error' event can only be only bound *after* this exception\r\n            // occurs.  Therefore, also, we cannot throw here at all.\r\n            this.setTimeoutFn(() => {\r\n                this.onError(e);\r\n            }, 0);\r\n            return;\r\n        }\r\n        if (typeof document !== \"undefined\") {\r\n            this.index = Request.requestsCount++;\r\n            Request.requests[this.index] = this;\r\n        }\r\n    }\r\n    /**\r\n     * Called upon error.\r\n     *\r\n     * @private\r\n     */\r\n    onError(err) {\r\n        this.emitReserved(\"error\", err, this.xhr);\r\n        this.cleanup(true);\r\n    }\r\n    /**\r\n     * Cleans up house.\r\n     *\r\n     * @private\r\n     */\r\n    cleanup(fromError) {\r\n        if (\"undefined\" === typeof this.xhr || null === this.xhr) {\r\n            return;\r\n        }\r\n        this.xhr.onreadystatechange = empty;\r\n        if (fromError) {\r\n            try {\r\n                this.xhr.abort();\r\n            }\r\n            catch (e) { }\r\n        }\r\n        if (typeof document !== \"undefined\") {\r\n            delete Request.requests[this.index];\r\n        }\r\n        this.xhr = null;\r\n    }\r\n    /**\r\n     * Called upon load.\r\n     *\r\n     * @private\r\n     */\r\n    onLoad() {\r\n        const data = this.xhr.responseText;\r\n        if (data !== null) {\r\n            this.emitReserved(\"data\", data);\r\n            this.emitReserved(\"success\");\r\n            this.cleanup();\r\n        }\r\n    }\r\n    /**\r\n     * Aborts the request.\r\n     *\r\n     * @package\r\n     */\r\n    abort() {\r\n        this.cleanup();\r\n    }\r\n}\r\nexports.Request = Request;\r\nRequest.requestsCount = 0;\r\nRequest.requests = {};\r\n/**\r\n * Aborts pending requests when unloading the window. This is needed to prevent\r\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\r\n * emitted.\r\n */\r\nif (typeof document !== \"undefined\") {\r\n    // @ts-ignore\r\n    if (typeof attachEvent === \"function\") {\r\n        // @ts-ignore\r\n        attachEvent(\"onunload\", unloadHandler);\r\n    }\r\n    else if (typeof addEventListener === \"function\") {\r\n        const terminationEvent = \"onpagehide\" in globalThis_js_1.globalThisShim ? \"pagehide\" : \"unload\";\r\n        addEventListener(terminationEvent, unloadHandler, false);\r\n    }\r\n}\r\nfunction unloadHandler() {\r\n    for (let i in Request.requests) {\r\n        if (Request.requests.hasOwnProperty(i)) {\r\n            Request.requests[i].abort();\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/build/cjs/transports/polling.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/build/cjs/transports/websocket-constructor.browser.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/engine.io-client/build/cjs/transports/websocket-constructor.browser.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.defaultBinaryType = exports.usingBrowserWebSocket = exports.WebSocket = exports.nextTick = void 0;\r\nconst globalThis_js_1 = __webpack_require__(/*! ../globalThis.js */ \"./node_modules/engine.io-client/build/cjs/globalThis.browser.js\");\r\nexports.nextTick = (() => {\r\n    const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\r\n    if (isPromiseAvailable) {\r\n        return (cb) => Promise.resolve().then(cb);\r\n    }\r\n    else {\r\n        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\r\n    }\r\n})();\r\nexports.WebSocket = globalThis_js_1.globalThisShim.WebSocket || globalThis_js_1.globalThisShim.MozWebSocket;\r\nexports.usingBrowserWebSocket = true;\r\nexports.defaultBinaryType = \"arraybuffer\";\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/build/cjs/transports/websocket-constructor.browser.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/build/cjs/transports/websocket.js":
/*!*************************************************************************!*\
  !*** ./node_modules/engine.io-client/build/cjs/transports/websocket.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.WS = void 0;\r\nconst transport_js_1 = __webpack_require__(/*! ../transport.js */ \"./node_modules/engine.io-client/build/cjs/transport.js\");\r\nconst yeast_js_1 = __webpack_require__(/*! ../contrib/yeast.js */ \"./node_modules/engine.io-client/build/cjs/contrib/yeast.js\");\r\nconst util_js_1 = __webpack_require__(/*! ../util.js */ \"./node_modules/engine.io-client/build/cjs/util.js\");\r\nconst websocket_constructor_js_1 = __webpack_require__(/*! ./websocket-constructor.js */ \"./node_modules/engine.io-client/build/cjs/transports/websocket-constructor.browser.js\");\r\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/engine.io-client/node_modules/debug/src/browser.js\")); // debug()\r\nconst engine_io_parser_1 = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/build/cjs/index.js\");\r\nconst debug = (0, debug_1.default)(\"engine.io-client:websocket\"); // debug()\r\n// detect ReactNative environment\r\nconst isReactNative = typeof navigator !== \"undefined\" &&\r\n    typeof navigator.product === \"string\" &&\r\n    navigator.product.toLowerCase() === \"reactnative\";\r\nclass WS extends transport_js_1.Transport {\r\n    /**\r\n     * WebSocket transport constructor.\r\n     *\r\n     * @param {Object} opts - connection options\r\n     * @protected\r\n     */\r\n    constructor(opts) {\r\n        super(opts);\r\n        this.supportsBinary = !opts.forceBase64;\r\n    }\r\n    get name() {\r\n        return \"websocket\";\r\n    }\r\n    doOpen() {\r\n        if (!this.check()) {\r\n            // let probe timeout\r\n            return;\r\n        }\r\n        const uri = this.uri();\r\n        const protocols = this.opts.protocols;\r\n        // React Native only supports the 'headers' option, and will print a warning if anything else is passed\r\n        const opts = isReactNative\r\n            ? {}\r\n            : (0, util_js_1.pick)(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\r\n        if (this.opts.extraHeaders) {\r\n            opts.headers = this.opts.extraHeaders;\r\n        }\r\n        try {\r\n            this.ws =\r\n                websocket_constructor_js_1.usingBrowserWebSocket && !isReactNative\r\n                    ? protocols\r\n                        ? new websocket_constructor_js_1.WebSocket(uri, protocols)\r\n                        : new websocket_constructor_js_1.WebSocket(uri)\r\n                    : new websocket_constructor_js_1.WebSocket(uri, protocols, opts);\r\n        }\r\n        catch (err) {\r\n            return this.emitReserved(\"error\", err);\r\n        }\r\n        this.ws.binaryType = this.socket.binaryType;\r\n        this.addEventListeners();\r\n    }\r\n    /**\r\n     * Adds event listeners to the socket\r\n     *\r\n     * @private\r\n     */\r\n    addEventListeners() {\r\n        this.ws.onopen = () => {\r\n            if (this.opts.autoUnref) {\r\n                this.ws._socket.unref();\r\n            }\r\n            this.onOpen();\r\n        };\r\n        this.ws.onclose = (closeEvent) => this.onClose({\r\n            description: \"websocket connection closed\",\r\n            context: closeEvent,\r\n        });\r\n        this.ws.onmessage = (ev) => this.onData(ev.data);\r\n        this.ws.onerror = (e) => this.onError(\"websocket error\", e);\r\n    }\r\n    write(packets) {\r\n        this.writable = false;\r\n        // encodePacket efficient as it uses WS framing\r\n        // no need for encodePayload\r\n        for (let i = 0; i < packets.length; i++) {\r\n            const packet = packets[i];\r\n            const lastPacket = i === packets.length - 1;\r\n            (0, engine_io_parser_1.encodePacket)(packet, this.supportsBinary, (data) => {\r\n                // always create a new object (GH-437)\r\n                const opts = {};\r\n                if (!websocket_constructor_js_1.usingBrowserWebSocket) {\r\n                    if (packet.options) {\r\n                        opts.compress = packet.options.compress;\r\n                    }\r\n                    if (this.opts.perMessageDeflate) {\r\n                        const len = \r\n                        // @ts-ignore\r\n                        \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\r\n                        if (len < this.opts.perMessageDeflate.threshold) {\r\n                            opts.compress = false;\r\n                        }\r\n                    }\r\n                }\r\n                // Sometimes the websocket has already been closed but the browser didn't\r\n                // have a chance of informing us about it yet, in that case send will\r\n                // throw an error\r\n                try {\r\n                    if (websocket_constructor_js_1.usingBrowserWebSocket) {\r\n                        // TypeError is thrown when passing the second argument on Safari\r\n                        this.ws.send(data);\r\n                    }\r\n                    else {\r\n                        this.ws.send(data, opts);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    debug(\"websocket closed before onclose event\");\r\n                }\r\n                if (lastPacket) {\r\n                    // fake drain\r\n                    // defer to next tick to allow Socket to clear writeBuffer\r\n                    (0, websocket_constructor_js_1.nextTick)(() => {\r\n                        this.writable = true;\r\n                        this.emitReserved(\"drain\");\r\n                    }, this.setTimeoutFn);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    doClose() {\r\n        if (typeof this.ws !== \"undefined\") {\r\n            this.ws.close();\r\n            this.ws = null;\r\n        }\r\n    }\r\n    /**\r\n     * Generates uri for connection.\r\n     *\r\n     * @private\r\n     */\r\n    uri() {\r\n        const schema = this.opts.secure ? \"wss\" : \"ws\";\r\n        const query = this.query || {};\r\n        // append timestamp to URI\r\n        if (this.opts.timestampRequests) {\r\n            query[this.opts.timestampParam] = (0, yeast_js_1.yeast)();\r\n        }\r\n        // communicate binary support capabilities\r\n        if (!this.supportsBinary) {\r\n            query.b64 = 1;\r\n        }\r\n        return this.createUri(schema, query);\r\n    }\r\n    /**\r\n     * Feature detection for WebSocket.\r\n     *\r\n     * @return {Boolean} whether this transport is available.\r\n     * @private\r\n     */\r\n    check() {\r\n        return !!websocket_constructor_js_1.WebSocket;\r\n    }\r\n}\r\nexports.WS = WS;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/build/cjs/transports/websocket.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/build/cjs/transports/webtransport.js":
/*!****************************************************************************!*\
  !*** ./node_modules/engine.io-client/build/cjs/transports/webtransport.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.WT = void 0;\r\nconst transport_js_1 = __webpack_require__(/*! ../transport.js */ \"./node_modules/engine.io-client/build/cjs/transport.js\");\r\nconst websocket_constructor_js_1 = __webpack_require__(/*! ./websocket-constructor.js */ \"./node_modules/engine.io-client/build/cjs/transports/websocket-constructor.browser.js\");\r\nconst engine_io_parser_1 = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/build/cjs/index.js\");\r\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/engine.io-client/node_modules/debug/src/browser.js\")); // debug()\r\nconst debug = (0, debug_1.default)(\"engine.io-client:webtransport\"); // debug()\r\nclass WT extends transport_js_1.Transport {\r\n    get name() {\r\n        return \"webtransport\";\r\n    }\r\n    doOpen() {\r\n        // @ts-ignore\r\n        if (typeof WebTransport !== \"function\") {\r\n            return;\r\n        }\r\n        // @ts-ignore\r\n        this.transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\r\n        this.transport.closed\r\n            .then(() => {\r\n            debug(\"transport closed gracefully\");\r\n            this.onClose();\r\n        })\r\n            .catch((err) => {\r\n            debug(\"transport closed due to %s\", err);\r\n            this.onError(\"webtransport error\", err);\r\n        });\r\n        // note: we could have used async/await, but that would require some additional polyfills\r\n        this.transport.ready.then(() => {\r\n            this.transport.createBidirectionalStream().then((stream) => {\r\n                const decoderStream = (0, engine_io_parser_1.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, this.socket.binaryType);\r\n                const reader = stream.readable.pipeThrough(decoderStream).getReader();\r\n                const encoderStream = (0, engine_io_parser_1.createPacketEncoderStream)();\r\n                encoderStream.readable.pipeTo(stream.writable);\r\n                this.writer = encoderStream.writable.getWriter();\r\n                const read = () => {\r\n                    reader\r\n                        .read()\r\n                        .then(({ done, value }) => {\r\n                        if (done) {\r\n                            debug(\"session is closed\");\r\n                            return;\r\n                        }\r\n                        debug(\"received chunk: %o\", value);\r\n                        this.onPacket(value);\r\n                        read();\r\n                    })\r\n                        .catch((err) => {\r\n                        debug(\"an error occurred while reading: %s\", err);\r\n                    });\r\n                };\r\n                read();\r\n                const packet = { type: \"open\" };\r\n                if (this.query.sid) {\r\n                    packet.data = `{\"sid\":\"${this.query.sid}\"}`;\r\n                }\r\n                this.writer.write(packet).then(() => this.onOpen());\r\n            });\r\n        });\r\n    }\r\n    write(packets) {\r\n        this.writable = false;\r\n        for (let i = 0; i < packets.length; i++) {\r\n            const packet = packets[i];\r\n            const lastPacket = i === packets.length - 1;\r\n            this.writer.write(packet).then(() => {\r\n                if (lastPacket) {\r\n                    (0, websocket_constructor_js_1.nextTick)(() => {\r\n                        this.writable = true;\r\n                        this.emitReserved(\"drain\");\r\n                    }, this.setTimeoutFn);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    doClose() {\r\n        var _a;\r\n        (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();\r\n    }\r\n}\r\nexports.WT = WT;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/build/cjs/transports/webtransport.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/build/cjs/transports/xmlhttprequest.browser.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/engine.io-client/build/cjs/transports/xmlhttprequest.browser.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\n// browser shim for xmlhttprequest module\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.createCookieJar = exports.XHR = void 0;\r\nconst has_cors_js_1 = __webpack_require__(/*! ../contrib/has-cors.js */ \"./node_modules/engine.io-client/build/cjs/contrib/has-cors.js\");\r\nconst globalThis_js_1 = __webpack_require__(/*! ../globalThis.js */ \"./node_modules/engine.io-client/build/cjs/globalThis.browser.js\");\r\nfunction XHR(opts) {\r\n    const xdomain = opts.xdomain;\r\n    // XMLHttpRequest can be disabled on IE\r\n    try {\r\n        if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || has_cors_js_1.hasCORS)) {\r\n            return new XMLHttpRequest();\r\n        }\r\n    }\r\n    catch (e) { }\r\n    if (!xdomain) {\r\n        try {\r\n            return new globalThis_js_1.globalThisShim[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\r\n        }\r\n        catch (e) { }\r\n    }\r\n}\r\nexports.XHR = XHR;\r\nfunction createCookieJar() { }\r\nexports.createCookieJar = createCookieJar;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/build/cjs/transports/xmlhttprequest.browser.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/build/cjs/util.js":
/*!*********************************************************!*\
  !*** ./node_modules/engine.io-client/build/cjs/util.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.byteLength = exports.installTimerFunctions = exports.pick = void 0;\r\nconst globalThis_js_1 = __webpack_require__(/*! ./globalThis.js */ \"./node_modules/engine.io-client/build/cjs/globalThis.browser.js\");\r\nfunction pick(obj, ...attr) {\r\n    return attr.reduce((acc, k) => {\r\n        if (obj.hasOwnProperty(k)) {\r\n            acc[k] = obj[k];\r\n        }\r\n        return acc;\r\n    }, {});\r\n}\r\nexports.pick = pick;\r\n// Keep a reference to the real timeout functions so they can be used when overridden\r\nconst NATIVE_SET_TIMEOUT = globalThis_js_1.globalThisShim.setTimeout;\r\nconst NATIVE_CLEAR_TIMEOUT = globalThis_js_1.globalThisShim.clearTimeout;\r\nfunction installTimerFunctions(obj, opts) {\r\n    if (opts.useNativeTimers) {\r\n        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis_js_1.globalThisShim);\r\n        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis_js_1.globalThisShim);\r\n    }\r\n    else {\r\n        obj.setTimeoutFn = globalThis_js_1.globalThisShim.setTimeout.bind(globalThis_js_1.globalThisShim);\r\n        obj.clearTimeoutFn = globalThis_js_1.globalThisShim.clearTimeout.bind(globalThis_js_1.globalThisShim);\r\n    }\r\n}\r\nexports.installTimerFunctions = installTimerFunctions;\r\n// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)\r\nconst BASE64_OVERHEAD = 1.33;\r\n// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9\r\nfunction byteLength(obj) {\r\n    if (typeof obj === \"string\") {\r\n        return utf8Length(obj);\r\n    }\r\n    // arraybuffer or blob\r\n    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);\r\n}\r\nexports.byteLength = byteLength;\r\nfunction utf8Length(str) {\r\n    let c = 0, length = 0;\r\n    for (let i = 0, l = str.length; i < l; i++) {\r\n        c = str.charCodeAt(i);\r\n        if (c < 0x80) {\r\n            length += 1;\r\n        }\r\n        else if (c < 0x800) {\r\n            length += 2;\r\n        }\r\n        else if (c < 0xd800 || c >= 0xe000) {\r\n            length += 3;\r\n        }\r\n        else {\r\n            i++;\r\n            length += 4;\r\n        }\r\n    }\r\n    return length;\r\n}\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-client/build/cjs/util.js?");

/***/ }),

/***/ "./node_modules/engine.io-parser/build/cjs/commons.js":
/*!************************************************************!*\
  !*** ./node_modules/engine.io-parser/build/cjs/commons.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;\r\nconst PACKET_TYPES = Object.create(null); // no Map = no polyfill\r\nexports.PACKET_TYPES = PACKET_TYPES;\r\nPACKET_TYPES[\"open\"] = \"0\";\r\nPACKET_TYPES[\"close\"] = \"1\";\r\nPACKET_TYPES[\"ping\"] = \"2\";\r\nPACKET_TYPES[\"pong\"] = \"3\";\r\nPACKET_TYPES[\"message\"] = \"4\";\r\nPACKET_TYPES[\"upgrade\"] = \"5\";\r\nPACKET_TYPES[\"noop\"] = \"6\";\r\nconst PACKET_TYPES_REVERSE = Object.create(null);\r\nexports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;\r\nObject.keys(PACKET_TYPES).forEach(key => {\r\n    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\r\n});\r\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" };\r\nexports.ERROR_PACKET = ERROR_PACKET;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-parser/build/cjs/commons.js?");

/***/ }),

/***/ "./node_modules/engine.io-parser/build/cjs/contrib/base64-arraybuffer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/engine.io-parser/build/cjs/contrib/base64-arraybuffer.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.decode = exports.encode = void 0;\r\n// imported from https://github.com/socketio/base64-arraybuffer\r\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n// Use a lookup table to find the index.\r\nconst lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\r\nfor (let i = 0; i < chars.length; i++) {\r\n    lookup[chars.charCodeAt(i)] = i;\r\n}\r\nconst encode = (arraybuffer) => {\r\n    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\r\n    for (i = 0; i < len; i += 3) {\r\n        base64 += chars[bytes[i] >> 2];\r\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\r\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\r\n        base64 += chars[bytes[i + 2] & 63];\r\n    }\r\n    if (len % 3 === 2) {\r\n        base64 = base64.substring(0, base64.length - 1) + '=';\r\n    }\r\n    else if (len % 3 === 1) {\r\n        base64 = base64.substring(0, base64.length - 2) + '==';\r\n    }\r\n    return base64;\r\n};\r\nexports.encode = encode;\r\nconst decode = (base64) => {\r\n    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\r\n    if (base64[base64.length - 1] === '=') {\r\n        bufferLength--;\r\n        if (base64[base64.length - 2] === '=') {\r\n            bufferLength--;\r\n        }\r\n    }\r\n    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\r\n    for (i = 0; i < len; i += 4) {\r\n        encoded1 = lookup[base64.charCodeAt(i)];\r\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\r\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\r\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\r\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\r\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\r\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\r\n    }\r\n    return arraybuffer;\r\n};\r\nexports.decode = decode;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-parser/build/cjs/contrib/base64-arraybuffer.js?");

/***/ }),

/***/ "./node_modules/engine.io-parser/build/cjs/decodePacket.browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/engine.io-parser/build/cjs/decodePacket.browser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.decodePacket = void 0;\r\nconst commons_js_1 = __webpack_require__(/*! ./commons.js */ \"./node_modules/engine.io-parser/build/cjs/commons.js\");\r\nconst base64_arraybuffer_js_1 = __webpack_require__(/*! ./contrib/base64-arraybuffer.js */ \"./node_modules/engine.io-parser/build/cjs/contrib/base64-arraybuffer.js\");\r\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\r\nconst decodePacket = (encodedPacket, binaryType) => {\r\n    if (typeof encodedPacket !== \"string\") {\r\n        return {\r\n            type: \"message\",\r\n            data: mapBinary(encodedPacket, binaryType)\r\n        };\r\n    }\r\n    const type = encodedPacket.charAt(0);\r\n    if (type === \"b\") {\r\n        return {\r\n            type: \"message\",\r\n            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\r\n        };\r\n    }\r\n    const packetType = commons_js_1.PACKET_TYPES_REVERSE[type];\r\n    if (!packetType) {\r\n        return commons_js_1.ERROR_PACKET;\r\n    }\r\n    return encodedPacket.length > 1\r\n        ? {\r\n            type: commons_js_1.PACKET_TYPES_REVERSE[type],\r\n            data: encodedPacket.substring(1)\r\n        }\r\n        : {\r\n            type: commons_js_1.PACKET_TYPES_REVERSE[type]\r\n        };\r\n};\r\nexports.decodePacket = decodePacket;\r\nconst decodeBase64Packet = (data, binaryType) => {\r\n    if (withNativeArrayBuffer) {\r\n        const decoded = (0, base64_arraybuffer_js_1.decode)(data);\r\n        return mapBinary(decoded, binaryType);\r\n    }\r\n    else {\r\n        return { base64: true, data }; // fallback for old browsers\r\n    }\r\n};\r\nconst mapBinary = (data, binaryType) => {\r\n    switch (binaryType) {\r\n        case \"blob\":\r\n            if (data instanceof Blob) {\r\n                // from WebSocket + binaryType \"blob\"\r\n                return data;\r\n            }\r\n            else {\r\n                // from HTTP long-polling or WebTransport\r\n                return new Blob([data]);\r\n            }\r\n        case \"arraybuffer\":\r\n        default:\r\n            if (data instanceof ArrayBuffer) {\r\n                // from HTTP long-polling (base64) or WebSocket + binaryType \"arraybuffer\"\r\n                return data;\r\n            }\r\n            else {\r\n                // from WebTransport (Uint8Array)\r\n                return data.buffer;\r\n            }\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-parser/build/cjs/decodePacket.browser.js?");

/***/ }),

/***/ "./node_modules/engine.io-parser/build/cjs/encodePacket.browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/engine.io-parser/build/cjs/encodePacket.browser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.encodePacket = exports.encodePacketToBinary = void 0;\r\nconst commons_js_1 = __webpack_require__(/*! ./commons.js */ \"./node_modules/engine.io-parser/build/cjs/commons.js\");\r\nconst withNativeBlob = typeof Blob === \"function\" ||\r\n    (typeof Blob !== \"undefined\" &&\r\n        Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\");\r\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\r\n// ArrayBuffer.isView method is not defined in IE10\r\nconst isView = obj => {\r\n    return typeof ArrayBuffer.isView === \"function\"\r\n        ? ArrayBuffer.isView(obj)\r\n        : obj && obj.buffer instanceof ArrayBuffer;\r\n};\r\nconst encodePacket = ({ type, data }, supportsBinary, callback) => {\r\n    if (withNativeBlob && data instanceof Blob) {\r\n        if (supportsBinary) {\r\n            return callback(data);\r\n        }\r\n        else {\r\n            return encodeBlobAsBase64(data, callback);\r\n        }\r\n    }\r\n    else if (withNativeArrayBuffer &&\r\n        (data instanceof ArrayBuffer || isView(data))) {\r\n        if (supportsBinary) {\r\n            return callback(data);\r\n        }\r\n        else {\r\n            return encodeBlobAsBase64(new Blob([data]), callback);\r\n        }\r\n    }\r\n    // plain string\r\n    return callback(commons_js_1.PACKET_TYPES[type] + (data || \"\"));\r\n};\r\nexports.encodePacket = encodePacket;\r\nconst encodeBlobAsBase64 = (data, callback) => {\r\n    const fileReader = new FileReader();\r\n    fileReader.onload = function () {\r\n        const content = fileReader.result.split(\",\")[1];\r\n        callback(\"b\" + (content || \"\"));\r\n    };\r\n    return fileReader.readAsDataURL(data);\r\n};\r\nfunction toArray(data) {\r\n    if (data instanceof Uint8Array) {\r\n        return data;\r\n    }\r\n    else if (data instanceof ArrayBuffer) {\r\n        return new Uint8Array(data);\r\n    }\r\n    else {\r\n        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\r\n    }\r\n}\r\nlet TEXT_ENCODER;\r\nfunction encodePacketToBinary(packet, callback) {\r\n    if (withNativeBlob && packet.data instanceof Blob) {\r\n        return packet.data\r\n            .arrayBuffer()\r\n            .then(toArray)\r\n            .then(callback);\r\n    }\r\n    else if (withNativeArrayBuffer &&\r\n        (packet.data instanceof ArrayBuffer || isView(packet.data))) {\r\n        return callback(toArray(packet.data));\r\n    }\r\n    encodePacket(packet, false, encoded => {\r\n        if (!TEXT_ENCODER) {\r\n            TEXT_ENCODER = new TextEncoder();\r\n        }\r\n        callback(TEXT_ENCODER.encode(encoded));\r\n    });\r\n}\r\nexports.encodePacketToBinary = encodePacketToBinary;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-parser/build/cjs/encodePacket.browser.js?");

/***/ }),

/***/ "./node_modules/engine.io-parser/build/cjs/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/engine.io-parser/build/cjs/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = exports.createPacketDecoderStream = exports.createPacketEncoderStream = void 0;\r\nconst encodePacket_js_1 = __webpack_require__(/*! ./encodePacket.js */ \"./node_modules/engine.io-parser/build/cjs/encodePacket.browser.js\");\r\nObject.defineProperty(exports, \"encodePacket\", ({ enumerable: true, get: function () { return encodePacket_js_1.encodePacket; } }));\r\nconst decodePacket_js_1 = __webpack_require__(/*! ./decodePacket.js */ \"./node_modules/engine.io-parser/build/cjs/decodePacket.browser.js\");\r\nObject.defineProperty(exports, \"decodePacket\", ({ enumerable: true, get: function () { return decodePacket_js_1.decodePacket; } }));\r\nconst commons_js_1 = __webpack_require__(/*! ./commons.js */ \"./node_modules/engine.io-parser/build/cjs/commons.js\");\r\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\r\nconst encodePayload = (packets, callback) => {\r\n    // some packets may be added to the array while encoding, so the initial length must be saved\r\n    const length = packets.length;\r\n    const encodedPackets = new Array(length);\r\n    let count = 0;\r\n    packets.forEach((packet, i) => {\r\n        // force base64 encoding for binary packets\r\n        (0, encodePacket_js_1.encodePacket)(packet, false, encodedPacket => {\r\n            encodedPackets[i] = encodedPacket;\r\n            if (++count === length) {\r\n                callback(encodedPackets.join(SEPARATOR));\r\n            }\r\n        });\r\n    });\r\n};\r\nexports.encodePayload = encodePayload;\r\nconst decodePayload = (encodedPayload, binaryType) => {\r\n    const encodedPackets = encodedPayload.split(SEPARATOR);\r\n    const packets = [];\r\n    for (let i = 0; i < encodedPackets.length; i++) {\r\n        const decodedPacket = (0, decodePacket_js_1.decodePacket)(encodedPackets[i], binaryType);\r\n        packets.push(decodedPacket);\r\n        if (decodedPacket.type === \"error\") {\r\n            break;\r\n        }\r\n    }\r\n    return packets;\r\n};\r\nexports.decodePayload = decodePayload;\r\nfunction createPacketEncoderStream() {\r\n    return new TransformStream({\r\n        transform(packet, controller) {\r\n            (0, encodePacket_js_1.encodePacketToBinary)(packet, encodedPacket => {\r\n                const payloadLength = encodedPacket.length;\r\n                let header;\r\n                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length\r\n                if (payloadLength < 126) {\r\n                    header = new Uint8Array(1);\r\n                    new DataView(header.buffer).setUint8(0, payloadLength);\r\n                }\r\n                else if (payloadLength < 65536) {\r\n                    header = new Uint8Array(3);\r\n                    const view = new DataView(header.buffer);\r\n                    view.setUint8(0, 126);\r\n                    view.setUint16(1, payloadLength);\r\n                }\r\n                else {\r\n                    header = new Uint8Array(9);\r\n                    const view = new DataView(header.buffer);\r\n                    view.setUint8(0, 127);\r\n                    view.setBigUint64(1, BigInt(payloadLength));\r\n                }\r\n                // first bit indicates whether the payload is plain text (0) or binary (1)\r\n                if (packet.data && typeof packet.data !== \"string\") {\r\n                    header[0] |= 0x80;\r\n                }\r\n                controller.enqueue(header);\r\n                controller.enqueue(encodedPacket);\r\n            });\r\n        }\r\n    });\r\n}\r\nexports.createPacketEncoderStream = createPacketEncoderStream;\r\nlet TEXT_DECODER;\r\nfunction totalLength(chunks) {\r\n    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);\r\n}\r\nfunction concatChunks(chunks, size) {\r\n    if (chunks[0].length === size) {\r\n        return chunks.shift();\r\n    }\r\n    const buffer = new Uint8Array(size);\r\n    let j = 0;\r\n    for (let i = 0; i < size; i++) {\r\n        buffer[i] = chunks[0][j++];\r\n        if (j === chunks[0].length) {\r\n            chunks.shift();\r\n            j = 0;\r\n        }\r\n    }\r\n    if (chunks.length && j < chunks[0].length) {\r\n        chunks[0] = chunks[0].slice(j);\r\n    }\r\n    return buffer;\r\n}\r\nfunction createPacketDecoderStream(maxPayload, binaryType) {\r\n    if (!TEXT_DECODER) {\r\n        TEXT_DECODER = new TextDecoder();\r\n    }\r\n    const chunks = [];\r\n    let state = 0 /* READ_HEADER */;\r\n    let expectedLength = -1;\r\n    let isBinary = false;\r\n    return new TransformStream({\r\n        transform(chunk, controller) {\r\n            chunks.push(chunk);\r\n            while (true) {\r\n                if (state === 0 /* READ_HEADER */) {\r\n                    if (totalLength(chunks) < 1) {\r\n                        break;\r\n                    }\r\n                    const header = concatChunks(chunks, 1);\r\n                    isBinary = (header[0] & 0x80) === 0x80;\r\n                    expectedLength = header[0] & 0x7f;\r\n                    if (expectedLength < 126) {\r\n                        state = 3 /* READ_PAYLOAD */;\r\n                    }\r\n                    else if (expectedLength === 126) {\r\n                        state = 1 /* READ_EXTENDED_LENGTH_16 */;\r\n                    }\r\n                    else {\r\n                        state = 2 /* READ_EXTENDED_LENGTH_64 */;\r\n                    }\r\n                }\r\n                else if (state === 1 /* READ_EXTENDED_LENGTH_16 */) {\r\n                    if (totalLength(chunks) < 2) {\r\n                        break;\r\n                    }\r\n                    const headerArray = concatChunks(chunks, 2);\r\n                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);\r\n                    state = 3 /* READ_PAYLOAD */;\r\n                }\r\n                else if (state === 2 /* READ_EXTENDED_LENGTH_64 */) {\r\n                    if (totalLength(chunks) < 8) {\r\n                        break;\r\n                    }\r\n                    const headerArray = concatChunks(chunks, 8);\r\n                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);\r\n                    const n = view.getUint32(0);\r\n                    if (n > Math.pow(2, 53 - 32) - 1) {\r\n                        // the maximum safe integer in JavaScript is 2^53 - 1\r\n                        controller.enqueue(commons_js_1.ERROR_PACKET);\r\n                        break;\r\n                    }\r\n                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);\r\n                    state = 3 /* READ_PAYLOAD */;\r\n                }\r\n                else {\r\n                    if (totalLength(chunks) < expectedLength) {\r\n                        break;\r\n                    }\r\n                    const data = concatChunks(chunks, expectedLength);\r\n                    controller.enqueue((0, decodePacket_js_1.decodePacket)(isBinary ? data : TEXT_DECODER.decode(data), binaryType));\r\n                    state = 0 /* READ_HEADER */;\r\n                }\r\n                if (expectedLength === 0 || expectedLength > maxPayload) {\r\n                    controller.enqueue(commons_js_1.ERROR_PACKET);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\nexports.createPacketDecoderStream = createPacketDecoderStream;\r\nexports.protocol = 4;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/engine.io-parser/build/cjs/index.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/build/cjs/contrib/backo2.js":
/*!*******************************************************************!*\
  !*** ./node_modules/socket.io-client/build/cjs/contrib/backo2.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\n/**\r\n * Initialize backoff timer with `opts`.\r\n *\r\n * - `min` initial timeout in milliseconds [100]\r\n * - `max` max timeout [10000]\r\n * - `jitter` [0]\r\n * - `factor` [2]\r\n *\r\n * @param {Object} opts\r\n * @api public\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Backoff = void 0;\r\nfunction Backoff(opts) {\r\n    opts = opts || {};\r\n    this.ms = opts.min || 100;\r\n    this.max = opts.max || 10000;\r\n    this.factor = opts.factor || 2;\r\n    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\r\n    this.attempts = 0;\r\n}\r\nexports.Backoff = Backoff;\r\n/**\r\n * Return the backoff duration.\r\n *\r\n * @return {Number}\r\n * @api public\r\n */\r\nBackoff.prototype.duration = function () {\r\n    var ms = this.ms * Math.pow(this.factor, this.attempts++);\r\n    if (this.jitter) {\r\n        var rand = Math.random();\r\n        var deviation = Math.floor(rand * this.jitter * ms);\r\n        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\r\n    }\r\n    return Math.min(ms, this.max) | 0;\r\n};\r\n/**\r\n * Reset the number of attempts.\r\n *\r\n * @api public\r\n */\r\nBackoff.prototype.reset = function () {\r\n    this.attempts = 0;\r\n};\r\n/**\r\n * Set the minimum duration\r\n *\r\n * @api public\r\n */\r\nBackoff.prototype.setMin = function (min) {\r\n    this.ms = min;\r\n};\r\n/**\r\n * Set the maximum duration\r\n *\r\n * @api public\r\n */\r\nBackoff.prototype.setMax = function (max) {\r\n    this.max = max;\r\n};\r\n/**\r\n * Set the jitter\r\n *\r\n * @api public\r\n */\r\nBackoff.prototype.setJitter = function (jitter) {\r\n    this.jitter = jitter;\r\n};\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/socket.io-client/build/cjs/contrib/backo2.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/build/cjs/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/socket.io-client/build/cjs/index.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports[\"default\"] = exports.connect = exports.io = exports.Socket = exports.Manager = exports.protocol = void 0;\r\nconst url_js_1 = __webpack_require__(/*! ./url.js */ \"./node_modules/socket.io-client/build/cjs/url.js\");\r\nconst manager_js_1 = __webpack_require__(/*! ./manager.js */ \"./node_modules/socket.io-client/build/cjs/manager.js\");\r\nObject.defineProperty(exports, \"Manager\", ({ enumerable: true, get: function () { return manager_js_1.Manager; } }));\r\nconst socket_js_1 = __webpack_require__(/*! ./socket.js */ \"./node_modules/socket.io-client/build/cjs/socket.js\");\r\nObject.defineProperty(exports, \"Socket\", ({ enumerable: true, get: function () { return socket_js_1.Socket; } }));\r\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/socket.io-client/node_modules/debug/src/browser.js\")); // debug()\r\nconst debug = debug_1.default(\"socket.io-client\"); // debug()\r\n/**\r\n * Managers cache.\r\n */\r\nconst cache = {};\r\nfunction lookup(uri, opts) {\r\n    if (typeof uri === \"object\") {\r\n        opts = uri;\r\n        uri = undefined;\r\n    }\r\n    opts = opts || {};\r\n    const parsed = url_js_1.url(uri, opts.path || \"/socket.io\");\r\n    const source = parsed.source;\r\n    const id = parsed.id;\r\n    const path = parsed.path;\r\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\r\n    const newConnection = opts.forceNew ||\r\n        opts[\"force new connection\"] ||\r\n        false === opts.multiplex ||\r\n        sameNamespace;\r\n    let io;\r\n    if (newConnection) {\r\n        debug(\"ignoring socket cache for %s\", source);\r\n        io = new manager_js_1.Manager(source, opts);\r\n    }\r\n    else {\r\n        if (!cache[id]) {\r\n            debug(\"new io instance for %s\", source);\r\n            cache[id] = new manager_js_1.Manager(source, opts);\r\n        }\r\n        io = cache[id];\r\n    }\r\n    if (parsed.query && !opts.query) {\r\n        opts.query = parsed.queryKey;\r\n    }\r\n    return io.socket(parsed.path, opts);\r\n}\r\nexports.io = lookup;\r\nexports.connect = lookup;\r\nexports[\"default\"] = lookup;\r\n// so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\r\n// namespace (e.g. `io.connect(...)`), for backward compatibility\r\nObject.assign(lookup, {\r\n    Manager: manager_js_1.Manager,\r\n    Socket: socket_js_1.Socket,\r\n    io: lookup,\r\n    connect: lookup,\r\n});\r\n/**\r\n * Protocol version.\r\n *\r\n * @public\r\n */\r\nvar socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"./node_modules/socket.io-parser/build/cjs/index.js\");\r\nObject.defineProperty(exports, \"protocol\", ({ enumerable: true, get: function () { return socket_io_parser_1.protocol; } }));\r\n\r\nmodule.exports = lookup;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/socket.io-client/build/cjs/index.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/build/cjs/manager.js":
/*!************************************************************!*\
  !*** ./node_modules/socket.io-client/build/cjs/manager.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Manager = void 0;\r\nconst engine_io_client_1 = __webpack_require__(/*! engine.io-client */ \"./node_modules/engine.io-client/build/cjs/index.js\");\r\nconst socket_js_1 = __webpack_require__(/*! ./socket.js */ \"./node_modules/socket.io-client/build/cjs/socket.js\");\r\nconst parser = __importStar(__webpack_require__(/*! socket.io-parser */ \"./node_modules/socket.io-parser/build/cjs/index.js\"));\r\nconst on_js_1 = __webpack_require__(/*! ./on.js */ \"./node_modules/socket.io-client/build/cjs/on.js\");\r\nconst backo2_js_1 = __webpack_require__(/*! ./contrib/backo2.js */ \"./node_modules/socket.io-client/build/cjs/contrib/backo2.js\");\r\nconst component_emitter_1 = __webpack_require__(/*! @socket.io/component-emitter */ \"./node_modules/@socket.io/component-emitter/index.mjs\");\r\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/socket.io-client/node_modules/debug/src/browser.js\")); // debug()\r\nconst debug = debug_1.default(\"socket.io-client:manager\"); // debug()\r\nclass Manager extends component_emitter_1.Emitter {\r\n    constructor(uri, opts) {\r\n        var _a;\r\n        super();\r\n        this.nsps = {};\r\n        this.subs = [];\r\n        if (uri && \"object\" === typeof uri) {\r\n            opts = uri;\r\n            uri = undefined;\r\n        }\r\n        opts = opts || {};\r\n        opts.path = opts.path || \"/socket.io\";\r\n        this.opts = opts;\r\n        engine_io_client_1.installTimerFunctions(this, opts);\r\n        this.reconnection(opts.reconnection !== false);\r\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\r\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\r\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\r\n        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\r\n        this.backoff = new backo2_js_1.Backoff({\r\n            min: this.reconnectionDelay(),\r\n            max: this.reconnectionDelayMax(),\r\n            jitter: this.randomizationFactor(),\r\n        });\r\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\r\n        this._readyState = \"closed\";\r\n        this.uri = uri;\r\n        const _parser = opts.parser || parser;\r\n        this.encoder = new _parser.Encoder();\r\n        this.decoder = new _parser.Decoder();\r\n        this._autoConnect = opts.autoConnect !== false;\r\n        if (this._autoConnect)\r\n            this.open();\r\n    }\r\n    reconnection(v) {\r\n        if (!arguments.length)\r\n            return this._reconnection;\r\n        this._reconnection = !!v;\r\n        return this;\r\n    }\r\n    reconnectionAttempts(v) {\r\n        if (v === undefined)\r\n            return this._reconnectionAttempts;\r\n        this._reconnectionAttempts = v;\r\n        return this;\r\n    }\r\n    reconnectionDelay(v) {\r\n        var _a;\r\n        if (v === undefined)\r\n            return this._reconnectionDelay;\r\n        this._reconnectionDelay = v;\r\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\r\n        return this;\r\n    }\r\n    randomizationFactor(v) {\r\n        var _a;\r\n        if (v === undefined)\r\n            return this._randomizationFactor;\r\n        this._randomizationFactor = v;\r\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\r\n        return this;\r\n    }\r\n    reconnectionDelayMax(v) {\r\n        var _a;\r\n        if (v === undefined)\r\n            return this._reconnectionDelayMax;\r\n        this._reconnectionDelayMax = v;\r\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\r\n        return this;\r\n    }\r\n    timeout(v) {\r\n        if (!arguments.length)\r\n            return this._timeout;\r\n        this._timeout = v;\r\n        return this;\r\n    }\r\n    /**\r\n     * Starts trying to reconnect if reconnection is enabled and we have not\r\n     * started reconnecting yet\r\n     *\r\n     * @private\r\n     */\r\n    maybeReconnectOnOpen() {\r\n        // Only try to reconnect if it's the first time we're connecting\r\n        if (!this._reconnecting &&\r\n            this._reconnection &&\r\n            this.backoff.attempts === 0) {\r\n            // keeps reconnection from firing twice for the same reconnection loop\r\n            this.reconnect();\r\n        }\r\n    }\r\n    /**\r\n     * Sets the current transport `socket`.\r\n     *\r\n     * @param {Function} fn - optional, callback\r\n     * @return self\r\n     * @public\r\n     */\r\n    open(fn) {\r\n        debug(\"readyState %s\", this._readyState);\r\n        if (~this._readyState.indexOf(\"open\"))\r\n            return this;\r\n        debug(\"opening %s\", this.uri);\r\n        this.engine = new engine_io_client_1.Socket(this.uri, this.opts);\r\n        const socket = this.engine;\r\n        const self = this;\r\n        this._readyState = \"opening\";\r\n        this.skipReconnect = false;\r\n        // emit `open`\r\n        const openSubDestroy = on_js_1.on(socket, \"open\", function () {\r\n            self.onopen();\r\n            fn && fn();\r\n        });\r\n        const onError = (err) => {\r\n            debug(\"error\");\r\n            this.cleanup();\r\n            this._readyState = \"closed\";\r\n            this.emitReserved(\"error\", err);\r\n            if (fn) {\r\n                fn(err);\r\n            }\r\n            else {\r\n                // Only do this if there is no fn to handle the error\r\n                this.maybeReconnectOnOpen();\r\n            }\r\n        };\r\n        // emit `error`\r\n        const errorSub = on_js_1.on(socket, \"error\", onError);\r\n        if (false !== this._timeout) {\r\n            const timeout = this._timeout;\r\n            debug(\"connect attempt will timeout after %d\", timeout);\r\n            // set timer\r\n            const timer = this.setTimeoutFn(() => {\r\n                debug(\"connect attempt timed out after %d\", timeout);\r\n                openSubDestroy();\r\n                onError(new Error(\"timeout\"));\r\n                socket.close();\r\n            }, timeout);\r\n            if (this.opts.autoUnref) {\r\n                timer.unref();\r\n            }\r\n            this.subs.push(() => {\r\n                this.clearTimeoutFn(timer);\r\n            });\r\n        }\r\n        this.subs.push(openSubDestroy);\r\n        this.subs.push(errorSub);\r\n        return this;\r\n    }\r\n    /**\r\n     * Alias for open()\r\n     *\r\n     * @return self\r\n     * @public\r\n     */\r\n    connect(fn) {\r\n        return this.open(fn);\r\n    }\r\n    /**\r\n     * Called upon transport open.\r\n     *\r\n     * @private\r\n     */\r\n    onopen() {\r\n        debug(\"open\");\r\n        // clear old subs\r\n        this.cleanup();\r\n        // mark as open\r\n        this._readyState = \"open\";\r\n        this.emitReserved(\"open\");\r\n        // add new subs\r\n        const socket = this.engine;\r\n        this.subs.push(on_js_1.on(socket, \"ping\", this.onping.bind(this)), on_js_1.on(socket, \"data\", this.ondata.bind(this)), on_js_1.on(socket, \"error\", this.onerror.bind(this)), on_js_1.on(socket, \"close\", this.onclose.bind(this)), on_js_1.on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\r\n    }\r\n    /**\r\n     * Called upon a ping.\r\n     *\r\n     * @private\r\n     */\r\n    onping() {\r\n        this.emitReserved(\"ping\");\r\n    }\r\n    /**\r\n     * Called with data.\r\n     *\r\n     * @private\r\n     */\r\n    ondata(data) {\r\n        try {\r\n            this.decoder.add(data);\r\n        }\r\n        catch (e) {\r\n            this.onclose(\"parse error\", e);\r\n        }\r\n    }\r\n    /**\r\n     * Called when parser fully decodes a packet.\r\n     *\r\n     * @private\r\n     */\r\n    ondecoded(packet) {\r\n        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a \"parse error\"\r\n        engine_io_client_1.nextTick(() => {\r\n            this.emitReserved(\"packet\", packet);\r\n        }, this.setTimeoutFn);\r\n    }\r\n    /**\r\n     * Called upon socket error.\r\n     *\r\n     * @private\r\n     */\r\n    onerror(err) {\r\n        debug(\"error\", err);\r\n        this.emitReserved(\"error\", err);\r\n    }\r\n    /**\r\n     * Creates a new socket for the given `nsp`.\r\n     *\r\n     * @return {Socket}\r\n     * @public\r\n     */\r\n    socket(nsp, opts) {\r\n        let socket = this.nsps[nsp];\r\n        if (!socket) {\r\n            socket = new socket_js_1.Socket(this, nsp, opts);\r\n            this.nsps[nsp] = socket;\r\n        }\r\n        else if (this._autoConnect && !socket.active) {\r\n            socket.connect();\r\n        }\r\n        return socket;\r\n    }\r\n    /**\r\n     * Called upon a socket close.\r\n     *\r\n     * @param socket\r\n     * @private\r\n     */\r\n    _destroy(socket) {\r\n        const nsps = Object.keys(this.nsps);\r\n        for (const nsp of nsps) {\r\n            const socket = this.nsps[nsp];\r\n            if (socket.active) {\r\n                debug(\"socket %s is still active, skipping close\", nsp);\r\n                return;\r\n            }\r\n        }\r\n        this._close();\r\n    }\r\n    /**\r\n     * Writes a packet.\r\n     *\r\n     * @param packet\r\n     * @private\r\n     */\r\n    _packet(packet) {\r\n        debug(\"writing packet %j\", packet);\r\n        const encodedPackets = this.encoder.encode(packet);\r\n        for (let i = 0; i < encodedPackets.length; i++) {\r\n            this.engine.write(encodedPackets[i], packet.options);\r\n        }\r\n    }\r\n    /**\r\n     * Clean up transport subscriptions and packet buffer.\r\n     *\r\n     * @private\r\n     */\r\n    cleanup() {\r\n        debug(\"cleanup\");\r\n        this.subs.forEach((subDestroy) => subDestroy());\r\n        this.subs.length = 0;\r\n        this.decoder.destroy();\r\n    }\r\n    /**\r\n     * Close the current socket.\r\n     *\r\n     * @private\r\n     */\r\n    _close() {\r\n        debug(\"disconnect\");\r\n        this.skipReconnect = true;\r\n        this._reconnecting = false;\r\n        this.onclose(\"forced close\");\r\n        if (this.engine)\r\n            this.engine.close();\r\n    }\r\n    /**\r\n     * Alias for close()\r\n     *\r\n     * @private\r\n     */\r\n    disconnect() {\r\n        return this._close();\r\n    }\r\n    /**\r\n     * Called upon engine close.\r\n     *\r\n     * @private\r\n     */\r\n    onclose(reason, description) {\r\n        debug(\"closed due to %s\", reason);\r\n        this.cleanup();\r\n        this.backoff.reset();\r\n        this._readyState = \"closed\";\r\n        this.emitReserved(\"close\", reason, description);\r\n        if (this._reconnection && !this.skipReconnect) {\r\n            this.reconnect();\r\n        }\r\n    }\r\n    /**\r\n     * Attempt a reconnection.\r\n     *\r\n     * @private\r\n     */\r\n    reconnect() {\r\n        if (this._reconnecting || this.skipReconnect)\r\n            return this;\r\n        const self = this;\r\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\r\n            debug(\"reconnect failed\");\r\n            this.backoff.reset();\r\n            this.emitReserved(\"reconnect_failed\");\r\n            this._reconnecting = false;\r\n        }\r\n        else {\r\n            const delay = this.backoff.duration();\r\n            debug(\"will wait %dms before reconnect attempt\", delay);\r\n            this._reconnecting = true;\r\n            const timer = this.setTimeoutFn(() => {\r\n                if (self.skipReconnect)\r\n                    return;\r\n                debug(\"attempting reconnect\");\r\n                this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\r\n                // check again for the case socket closed in above events\r\n                if (self.skipReconnect)\r\n                    return;\r\n                self.open((err) => {\r\n                    if (err) {\r\n                        debug(\"reconnect attempt error\");\r\n                        self._reconnecting = false;\r\n                        self.reconnect();\r\n                        this.emitReserved(\"reconnect_error\", err);\r\n                    }\r\n                    else {\r\n                        debug(\"reconnect success\");\r\n                        self.onreconnect();\r\n                    }\r\n                });\r\n            }, delay);\r\n            if (this.opts.autoUnref) {\r\n                timer.unref();\r\n            }\r\n            this.subs.push(() => {\r\n                this.clearTimeoutFn(timer);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Called upon successful reconnect.\r\n     *\r\n     * @private\r\n     */\r\n    onreconnect() {\r\n        const attempt = this.backoff.attempts;\r\n        this._reconnecting = false;\r\n        this.backoff.reset();\r\n        this.emitReserved(\"reconnect\", attempt);\r\n    }\r\n}\r\nexports.Manager = Manager;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/socket.io-client/build/cjs/manager.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/build/cjs/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/socket.io-client/build/cjs/on.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.on = void 0;\r\nfunction on(obj, ev, fn) {\r\n    obj.on(ev, fn);\r\n    return function subDestroy() {\r\n        obj.off(ev, fn);\r\n    };\r\n}\r\nexports.on = on;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/socket.io-client/build/cjs/on.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/build/cjs/socket.js":
/*!***********************************************************!*\
  !*** ./node_modules/socket.io-client/build/cjs/socket.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Socket = void 0;\r\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"./node_modules/socket.io-parser/build/cjs/index.js\");\r\nconst on_js_1 = __webpack_require__(/*! ./on.js */ \"./node_modules/socket.io-client/build/cjs/on.js\");\r\nconst component_emitter_1 = __webpack_require__(/*! @socket.io/component-emitter */ \"./node_modules/@socket.io/component-emitter/index.mjs\");\r\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/socket.io-client/node_modules/debug/src/browser.js\")); // debug()\r\nconst debug = debug_1.default(\"socket.io-client:socket\"); // debug()\r\n/**\r\n * Internal events.\r\n * These events can't be emitted by the user.\r\n */\r\nconst RESERVED_EVENTS = Object.freeze({\r\n    connect: 1,\r\n    connect_error: 1,\r\n    disconnect: 1,\r\n    disconnecting: 1,\r\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\r\n    newListener: 1,\r\n    removeListener: 1,\r\n});\r\n/**\r\n * A Socket is the fundamental class for interacting with the server.\r\n *\r\n * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.\r\n *\r\n * @example\r\n * const socket = io();\r\n *\r\n * socket.on(\"connect\", () => {\r\n *   console.log(\"connected\");\r\n * });\r\n *\r\n * // send an event to the server\r\n * socket.emit(\"foo\", \"bar\");\r\n *\r\n * socket.on(\"foobar\", () => {\r\n *   // an event was received from the server\r\n * });\r\n *\r\n * // upon disconnection\r\n * socket.on(\"disconnect\", (reason) => {\r\n *   console.log(`disconnected due to ${reason}`);\r\n * });\r\n */\r\nclass Socket extends component_emitter_1.Emitter {\r\n    /**\r\n     * `Socket` constructor.\r\n     */\r\n    constructor(io, nsp, opts) {\r\n        super();\r\n        /**\r\n         * Whether the socket is currently connected to the server.\r\n         *\r\n         * @example\r\n         * const socket = io();\r\n         *\r\n         * socket.on(\"connect\", () => {\r\n         *   console.log(socket.connected); // true\r\n         * });\r\n         *\r\n         * socket.on(\"disconnect\", () => {\r\n         *   console.log(socket.connected); // false\r\n         * });\r\n         */\r\n        this.connected = false;\r\n        /**\r\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\r\n         * be transmitted by the server.\r\n         */\r\n        this.recovered = false;\r\n        /**\r\n         * Buffer for packets received before the CONNECT packet\r\n         */\r\n        this.receiveBuffer = [];\r\n        /**\r\n         * Buffer for packets that will be sent once the socket is connected\r\n         */\r\n        this.sendBuffer = [];\r\n        /**\r\n         * The queue of packets to be sent with retry in case of failure.\r\n         *\r\n         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.\r\n         * @private\r\n         */\r\n        this._queue = [];\r\n        /**\r\n         * A sequence to generate the ID of the {@link QueuedPacket}.\r\n         * @private\r\n         */\r\n        this._queueSeq = 0;\r\n        this.ids = 0;\r\n        this.acks = {};\r\n        this.flags = {};\r\n        this.io = io;\r\n        this.nsp = nsp;\r\n        if (opts && opts.auth) {\r\n            this.auth = opts.auth;\r\n        }\r\n        this._opts = Object.assign({}, opts);\r\n        if (this.io._autoConnect)\r\n            this.open();\r\n    }\r\n    /**\r\n     * Whether the socket is currently disconnected\r\n     *\r\n     * @example\r\n     * const socket = io();\r\n     *\r\n     * socket.on(\"connect\", () => {\r\n     *   console.log(socket.disconnected); // false\r\n     * });\r\n     *\r\n     * socket.on(\"disconnect\", () => {\r\n     *   console.log(socket.disconnected); // true\r\n     * });\r\n     */\r\n    get disconnected() {\r\n        return !this.connected;\r\n    }\r\n    /**\r\n     * Subscribe to open, close and packet events\r\n     *\r\n     * @private\r\n     */\r\n    subEvents() {\r\n        if (this.subs)\r\n            return;\r\n        const io = this.io;\r\n        this.subs = [\r\n            on_js_1.on(io, \"open\", this.onopen.bind(this)),\r\n            on_js_1.on(io, \"packet\", this.onpacket.bind(this)),\r\n            on_js_1.on(io, \"error\", this.onerror.bind(this)),\r\n            on_js_1.on(io, \"close\", this.onclose.bind(this)),\r\n        ];\r\n    }\r\n    /**\r\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects.\r\n     *\r\n     * @example\r\n     * const socket = io();\r\n     *\r\n     * console.log(socket.active); // true\r\n     *\r\n     * socket.on(\"disconnect\", (reason) => {\r\n     *   if (reason === \"io server disconnect\") {\r\n     *     // the disconnection was initiated by the server, you need to manually reconnect\r\n     *     console.log(socket.active); // false\r\n     *   }\r\n     *   // else the socket will automatically try to reconnect\r\n     *   console.log(socket.active); // true\r\n     * });\r\n     */\r\n    get active() {\r\n        return !!this.subs;\r\n    }\r\n    /**\r\n     * \"Opens\" the socket.\r\n     *\r\n     * @example\r\n     * const socket = io({\r\n     *   autoConnect: false\r\n     * });\r\n     *\r\n     * socket.connect();\r\n     */\r\n    connect() {\r\n        if (this.connected)\r\n            return this;\r\n        this.subEvents();\r\n        if (!this.io[\"_reconnecting\"])\r\n            this.io.open(); // ensure open\r\n        if (\"open\" === this.io._readyState)\r\n            this.onopen();\r\n        return this;\r\n    }\r\n    /**\r\n     * Alias for {@link connect()}.\r\n     */\r\n    open() {\r\n        return this.connect();\r\n    }\r\n    /**\r\n     * Sends a `message` event.\r\n     *\r\n     * This method mimics the WebSocket.send() method.\r\n     *\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\r\n     *\r\n     * @example\r\n     * socket.send(\"hello\");\r\n     *\r\n     * // this is equivalent to\r\n     * socket.emit(\"message\", \"hello\");\r\n     *\r\n     * @return self\r\n     */\r\n    send(...args) {\r\n        args.unshift(\"message\");\r\n        this.emit.apply(this, args);\r\n        return this;\r\n    }\r\n    /**\r\n     * Override `emit`.\r\n     * If the event is in `events`, it's emitted normally.\r\n     *\r\n     * @example\r\n     * socket.emit(\"hello\", \"world\");\r\n     *\r\n     * // all serializable datastructures are supported (no need to call JSON.stringify)\r\n     * socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\r\n     *\r\n     * // with an acknowledgement from the server\r\n     * socket.emit(\"hello\", \"world\", (val) => {\r\n     *   // ...\r\n     * });\r\n     *\r\n     * @return self\r\n     */\r\n    emit(ev, ...args) {\r\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\r\n            throw new Error('\"' + ev.toString() + '\" is a reserved event name');\r\n        }\r\n        args.unshift(ev);\r\n        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {\r\n            this._addToQueue(args);\r\n            return this;\r\n        }\r\n        const packet = {\r\n            type: socket_io_parser_1.PacketType.EVENT,\r\n            data: args,\r\n        };\r\n        packet.options = {};\r\n        packet.options.compress = this.flags.compress !== false;\r\n        // event ack callback\r\n        if (\"function\" === typeof args[args.length - 1]) {\r\n            const id = this.ids++;\r\n            debug(\"emitting packet with ack id %d\", id);\r\n            const ack = args.pop();\r\n            this._registerAckCallback(id, ack);\r\n            packet.id = id;\r\n        }\r\n        const isTransportWritable = this.io.engine &&\r\n            this.io.engine.transport &&\r\n            this.io.engine.transport.writable;\r\n        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\r\n        if (discardPacket) {\r\n            debug(\"discard packet as the transport is not currently writable\");\r\n        }\r\n        else if (this.connected) {\r\n            this.notifyOutgoingListeners(packet);\r\n            this.packet(packet);\r\n        }\r\n        else {\r\n            this.sendBuffer.push(packet);\r\n        }\r\n        this.flags = {};\r\n        return this;\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    _registerAckCallback(id, ack) {\r\n        var _a;\r\n        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;\r\n        if (timeout === undefined) {\r\n            this.acks[id] = ack;\r\n            return;\r\n        }\r\n        // @ts-ignore\r\n        const timer = this.io.setTimeoutFn(() => {\r\n            delete this.acks[id];\r\n            for (let i = 0; i < this.sendBuffer.length; i++) {\r\n                if (this.sendBuffer[i].id === id) {\r\n                    debug(\"removing packet with ack id %d from the buffer\", id);\r\n                    this.sendBuffer.splice(i, 1);\r\n                }\r\n            }\r\n            debug(\"event with ack id %d has timed out after %d ms\", id, timeout);\r\n            ack.call(this, new Error(\"operation has timed out\"));\r\n        }, timeout);\r\n        this.acks[id] = (...args) => {\r\n            // @ts-ignore\r\n            this.io.clearTimeoutFn(timer);\r\n            ack.apply(this, [null, ...args]);\r\n        };\r\n    }\r\n    /**\r\n     * Emits an event and waits for an acknowledgement\r\n     *\r\n     * @example\r\n     * // without timeout\r\n     * const response = await socket.emitWithAck(\"hello\", \"world\");\r\n     *\r\n     * // with a specific timeout\r\n     * try {\r\n     *   const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\r\n     * } catch (err) {\r\n     *   // the server did not acknowledge the event in the given delay\r\n     * }\r\n     *\r\n     * @return a Promise that will be fulfilled when the server acknowledges the event\r\n     */\r\n    emitWithAck(ev, ...args) {\r\n        // the timeout flag is optional\r\n        const withErr = this.flags.timeout !== undefined || this._opts.ackTimeout !== undefined;\r\n        return new Promise((resolve, reject) => {\r\n            args.push((arg1, arg2) => {\r\n                if (withErr) {\r\n                    return arg1 ? reject(arg1) : resolve(arg2);\r\n                }\r\n                else {\r\n                    return resolve(arg1);\r\n                }\r\n            });\r\n            this.emit(ev, ...args);\r\n        });\r\n    }\r\n    /**\r\n     * Add the packet to the queue.\r\n     * @param args\r\n     * @private\r\n     */\r\n    _addToQueue(args) {\r\n        let ack;\r\n        if (typeof args[args.length - 1] === \"function\") {\r\n            ack = args.pop();\r\n        }\r\n        const packet = {\r\n            id: this._queueSeq++,\r\n            tryCount: 0,\r\n            pending: false,\r\n            args,\r\n            flags: Object.assign({ fromQueue: true }, this.flags),\r\n        };\r\n        args.push((err, ...responseArgs) => {\r\n            if (packet !== this._queue[0]) {\r\n                // the packet has already been acknowledged\r\n                return;\r\n            }\r\n            const hasError = err !== null;\r\n            if (hasError) {\r\n                if (packet.tryCount > this._opts.retries) {\r\n                    debug(\"packet [%d] is discarded after %d tries\", packet.id, packet.tryCount);\r\n                    this._queue.shift();\r\n                    if (ack) {\r\n                        ack(err);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                debug(\"packet [%d] was successfully sent\", packet.id);\r\n                this._queue.shift();\r\n                if (ack) {\r\n                    ack(null, ...responseArgs);\r\n                }\r\n            }\r\n            packet.pending = false;\r\n            return this._drainQueue();\r\n        });\r\n        this._queue.push(packet);\r\n        this._drainQueue();\r\n    }\r\n    /**\r\n     * Send the first packet of the queue, and wait for an acknowledgement from the server.\r\n     * @param force - whether to resend a packet that has not been acknowledged yet\r\n     *\r\n     * @private\r\n     */\r\n    _drainQueue(force = false) {\r\n        debug(\"draining queue\");\r\n        if (!this.connected || this._queue.length === 0) {\r\n            return;\r\n        }\r\n        const packet = this._queue[0];\r\n        if (packet.pending && !force) {\r\n            debug(\"packet [%d] has already been sent and is waiting for an ack\", packet.id);\r\n            return;\r\n        }\r\n        packet.pending = true;\r\n        packet.tryCount++;\r\n        debug(\"sending packet [%d] (try n°%d)\", packet.id, packet.tryCount);\r\n        this.flags = packet.flags;\r\n        this.emit.apply(this, packet.args);\r\n    }\r\n    /**\r\n     * Sends a packet.\r\n     *\r\n     * @param packet\r\n     * @private\r\n     */\r\n    packet(packet) {\r\n        packet.nsp = this.nsp;\r\n        this.io._packet(packet);\r\n    }\r\n    /**\r\n     * Called upon engine `open`.\r\n     *\r\n     * @private\r\n     */\r\n    onopen() {\r\n        debug(\"transport is open - connecting\");\r\n        if (typeof this.auth == \"function\") {\r\n            this.auth((data) => {\r\n                this._sendConnectPacket(data);\r\n            });\r\n        }\r\n        else {\r\n            this._sendConnectPacket(this.auth);\r\n        }\r\n    }\r\n    /**\r\n     * Sends a CONNECT packet to initiate the Socket.IO session.\r\n     *\r\n     * @param data\r\n     * @private\r\n     */\r\n    _sendConnectPacket(data) {\r\n        this.packet({\r\n            type: socket_io_parser_1.PacketType.CONNECT,\r\n            data: this._pid\r\n                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)\r\n                : data,\r\n        });\r\n    }\r\n    /**\r\n     * Called upon engine or manager `error`.\r\n     *\r\n     * @param err\r\n     * @private\r\n     */\r\n    onerror(err) {\r\n        if (!this.connected) {\r\n            this.emitReserved(\"connect_error\", err);\r\n        }\r\n    }\r\n    /**\r\n     * Called upon engine `close`.\r\n     *\r\n     * @param reason\r\n     * @param description\r\n     * @private\r\n     */\r\n    onclose(reason, description) {\r\n        debug(\"close (%s)\", reason);\r\n        this.connected = false;\r\n        delete this.id;\r\n        this.emitReserved(\"disconnect\", reason, description);\r\n    }\r\n    /**\r\n     * Called with socket packet.\r\n     *\r\n     * @param packet\r\n     * @private\r\n     */\r\n    onpacket(packet) {\r\n        const sameNamespace = packet.nsp === this.nsp;\r\n        if (!sameNamespace)\r\n            return;\r\n        switch (packet.type) {\r\n            case socket_io_parser_1.PacketType.CONNECT:\r\n                if (packet.data && packet.data.sid) {\r\n                    this.onconnect(packet.data.sid, packet.data.pid);\r\n                }\r\n                else {\r\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\r\n                }\r\n                break;\r\n            case socket_io_parser_1.PacketType.EVENT:\r\n            case socket_io_parser_1.PacketType.BINARY_EVENT:\r\n                this.onevent(packet);\r\n                break;\r\n            case socket_io_parser_1.PacketType.ACK:\r\n            case socket_io_parser_1.PacketType.BINARY_ACK:\r\n                this.onack(packet);\r\n                break;\r\n            case socket_io_parser_1.PacketType.DISCONNECT:\r\n                this.ondisconnect();\r\n                break;\r\n            case socket_io_parser_1.PacketType.CONNECT_ERROR:\r\n                this.destroy();\r\n                const err = new Error(packet.data.message);\r\n                // @ts-ignore\r\n                err.data = packet.data.data;\r\n                this.emitReserved(\"connect_error\", err);\r\n                break;\r\n        }\r\n    }\r\n    /**\r\n     * Called upon a server event.\r\n     *\r\n     * @param packet\r\n     * @private\r\n     */\r\n    onevent(packet) {\r\n        const args = packet.data || [];\r\n        debug(\"emitting event %j\", args);\r\n        if (null != packet.id) {\r\n            debug(\"attaching ack callback to event\");\r\n            args.push(this.ack(packet.id));\r\n        }\r\n        if (this.connected) {\r\n            this.emitEvent(args);\r\n        }\r\n        else {\r\n            this.receiveBuffer.push(Object.freeze(args));\r\n        }\r\n    }\r\n    emitEvent(args) {\r\n        if (this._anyListeners && this._anyListeners.length) {\r\n            const listeners = this._anyListeners.slice();\r\n            for (const listener of listeners) {\r\n                listener.apply(this, args);\r\n            }\r\n        }\r\n        super.emit.apply(this, args);\r\n        if (this._pid && args.length && typeof args[args.length - 1] === \"string\") {\r\n            this._lastOffset = args[args.length - 1];\r\n        }\r\n    }\r\n    /**\r\n     * Produces an ack callback to emit with an event.\r\n     *\r\n     * @private\r\n     */\r\n    ack(id) {\r\n        const self = this;\r\n        let sent = false;\r\n        return function (...args) {\r\n            // prevent double callbacks\r\n            if (sent)\r\n                return;\r\n            sent = true;\r\n            debug(\"sending ack %j\", args);\r\n            self.packet({\r\n                type: socket_io_parser_1.PacketType.ACK,\r\n                id: id,\r\n                data: args,\r\n            });\r\n        };\r\n    }\r\n    /**\r\n     * Called upon a server acknowlegement.\r\n     *\r\n     * @param packet\r\n     * @private\r\n     */\r\n    onack(packet) {\r\n        const ack = this.acks[packet.id];\r\n        if (\"function\" === typeof ack) {\r\n            debug(\"calling ack %s with %j\", packet.id, packet.data);\r\n            ack.apply(this, packet.data);\r\n            delete this.acks[packet.id];\r\n        }\r\n        else {\r\n            debug(\"bad ack %s\", packet.id);\r\n        }\r\n    }\r\n    /**\r\n     * Called upon server connect.\r\n     *\r\n     * @private\r\n     */\r\n    onconnect(id, pid) {\r\n        debug(\"socket connected with id %s\", id);\r\n        this.id = id;\r\n        this.recovered = pid && this._pid === pid;\r\n        this._pid = pid; // defined only if connection state recovery is enabled\r\n        this.connected = true;\r\n        this.emitBuffered();\r\n        this.emitReserved(\"connect\");\r\n        this._drainQueue(true);\r\n    }\r\n    /**\r\n     * Emit buffered events (received and emitted).\r\n     *\r\n     * @private\r\n     */\r\n    emitBuffered() {\r\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\r\n        this.receiveBuffer = [];\r\n        this.sendBuffer.forEach((packet) => {\r\n            this.notifyOutgoingListeners(packet);\r\n            this.packet(packet);\r\n        });\r\n        this.sendBuffer = [];\r\n    }\r\n    /**\r\n     * Called upon server disconnect.\r\n     *\r\n     * @private\r\n     */\r\n    ondisconnect() {\r\n        debug(\"server disconnect (%s)\", this.nsp);\r\n        this.destroy();\r\n        this.onclose(\"io server disconnect\");\r\n    }\r\n    /**\r\n     * Called upon forced client/server side disconnections,\r\n     * this method ensures the manager stops tracking us and\r\n     * that reconnections don't get triggered for this.\r\n     *\r\n     * @private\r\n     */\r\n    destroy() {\r\n        if (this.subs) {\r\n            // clean subscriptions to avoid reconnections\r\n            this.subs.forEach((subDestroy) => subDestroy());\r\n            this.subs = undefined;\r\n        }\r\n        this.io[\"_destroy\"](this);\r\n    }\r\n    /**\r\n     * Disconnects the socket manually. In that case, the socket will not try to reconnect.\r\n     *\r\n     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.\r\n     *\r\n     * @example\r\n     * const socket = io();\r\n     *\r\n     * socket.on(\"disconnect\", (reason) => {\r\n     *   // console.log(reason); prints \"io client disconnect\"\r\n     * });\r\n     *\r\n     * socket.disconnect();\r\n     *\r\n     * @return self\r\n     */\r\n    disconnect() {\r\n        if (this.connected) {\r\n            debug(\"performing disconnect (%s)\", this.nsp);\r\n            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });\r\n        }\r\n        // remove socket from pool\r\n        this.destroy();\r\n        if (this.connected) {\r\n            // fire events\r\n            this.onclose(\"io client disconnect\");\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Alias for {@link disconnect()}.\r\n     *\r\n     * @return self\r\n     */\r\n    close() {\r\n        return this.disconnect();\r\n    }\r\n    /**\r\n     * Sets the compress flag.\r\n     *\r\n     * @example\r\n     * socket.compress(false).emit(\"hello\");\r\n     *\r\n     * @param compress - if `true`, compresses the sending data\r\n     * @return self\r\n     */\r\n    compress(compress) {\r\n        this.flags.compress = compress;\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\r\n     * ready to send messages.\r\n     *\r\n     * @example\r\n     * socket.volatile.emit(\"hello\"); // the server may or may not receive it\r\n     *\r\n     * @returns self\r\n     */\r\n    get volatile() {\r\n        this.flags.volatile = true;\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\r\n     * given number of milliseconds have elapsed without an acknowledgement from the server:\r\n     *\r\n     * @example\r\n     * socket.timeout(5000).emit(\"my-event\", (err) => {\r\n     *   if (err) {\r\n     *     // the server did not acknowledge the event in the given delay\r\n     *   }\r\n     * });\r\n     *\r\n     * @returns self\r\n     */\r\n    timeout(timeout) {\r\n        this.flags.timeout = timeout;\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\r\n     * callback.\r\n     *\r\n     * @example\r\n     * socket.onAny((event, ...args) => {\r\n     *   console.log(`got ${event}`);\r\n     * });\r\n     *\r\n     * @param listener\r\n     */\r\n    onAny(listener) {\r\n        this._anyListeners = this._anyListeners || [];\r\n        this._anyListeners.push(listener);\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\r\n     * callback. The listener is added to the beginning of the listeners array.\r\n     *\r\n     * @example\r\n     * socket.prependAny((event, ...args) => {\r\n     *   console.log(`got event ${event}`);\r\n     * });\r\n     *\r\n     * @param listener\r\n     */\r\n    prependAny(listener) {\r\n        this._anyListeners = this._anyListeners || [];\r\n        this._anyListeners.unshift(listener);\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes the listener that will be fired when any event is emitted.\r\n     *\r\n     * @example\r\n     * const catchAllListener = (event, ...args) => {\r\n     *   console.log(`got event ${event}`);\r\n     * }\r\n     *\r\n     * socket.onAny(catchAllListener);\r\n     *\r\n     * // remove a specific listener\r\n     * socket.offAny(catchAllListener);\r\n     *\r\n     * // or remove all listeners\r\n     * socket.offAny();\r\n     *\r\n     * @param listener\r\n     */\r\n    offAny(listener) {\r\n        if (!this._anyListeners) {\r\n            return this;\r\n        }\r\n        if (listener) {\r\n            const listeners = this._anyListeners;\r\n            for (let i = 0; i < listeners.length; i++) {\r\n                if (listener === listeners[i]) {\r\n                    listeners.splice(i, 1);\r\n                    return this;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this._anyListeners = [];\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\r\n     * e.g. to remove listeners.\r\n     */\r\n    listenersAny() {\r\n        return this._anyListeners || [];\r\n    }\r\n    /**\r\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\r\n     * callback.\r\n     *\r\n     * Note: acknowledgements sent to the server are not included.\r\n     *\r\n     * @example\r\n     * socket.onAnyOutgoing((event, ...args) => {\r\n     *   console.log(`sent event ${event}`);\r\n     * });\r\n     *\r\n     * @param listener\r\n     */\r\n    onAnyOutgoing(listener) {\r\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\r\n        this._anyOutgoingListeners.push(listener);\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\r\n     * callback. The listener is added to the beginning of the listeners array.\r\n     *\r\n     * Note: acknowledgements sent to the server are not included.\r\n     *\r\n     * @example\r\n     * socket.prependAnyOutgoing((event, ...args) => {\r\n     *   console.log(`sent event ${event}`);\r\n     * });\r\n     *\r\n     * @param listener\r\n     */\r\n    prependAnyOutgoing(listener) {\r\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\r\n        this._anyOutgoingListeners.unshift(listener);\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes the listener that will be fired when any event is emitted.\r\n     *\r\n     * @example\r\n     * const catchAllListener = (event, ...args) => {\r\n     *   console.log(`sent event ${event}`);\r\n     * }\r\n     *\r\n     * socket.onAnyOutgoing(catchAllListener);\r\n     *\r\n     * // remove a specific listener\r\n     * socket.offAnyOutgoing(catchAllListener);\r\n     *\r\n     * // or remove all listeners\r\n     * socket.offAnyOutgoing();\r\n     *\r\n     * @param [listener] - the catch-all listener (optional)\r\n     */\r\n    offAnyOutgoing(listener) {\r\n        if (!this._anyOutgoingListeners) {\r\n            return this;\r\n        }\r\n        if (listener) {\r\n            const listeners = this._anyOutgoingListeners;\r\n            for (let i = 0; i < listeners.length; i++) {\r\n                if (listener === listeners[i]) {\r\n                    listeners.splice(i, 1);\r\n                    return this;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this._anyOutgoingListeners = [];\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\r\n     * e.g. to remove listeners.\r\n     */\r\n    listenersAnyOutgoing() {\r\n        return this._anyOutgoingListeners || [];\r\n    }\r\n    /**\r\n     * Notify the listeners for each packet sent\r\n     *\r\n     * @param packet\r\n     *\r\n     * @private\r\n     */\r\n    notifyOutgoingListeners(packet) {\r\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\r\n            const listeners = this._anyOutgoingListeners.slice();\r\n            for (const listener of listeners) {\r\n                listener.apply(this, packet.data);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.Socket = Socket;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/socket.io-client/build/cjs/socket.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/build/cjs/url.js":
/*!********************************************************!*\
  !*** ./node_modules/socket.io-client/build/cjs/url.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.url = void 0;\r\nconst engine_io_client_1 = __webpack_require__(/*! engine.io-client */ \"./node_modules/engine.io-client/build/cjs/index.js\");\r\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/socket.io-client/node_modules/debug/src/browser.js\")); // debug()\r\nconst debug = debug_1.default(\"socket.io-client:url\"); // debug()\r\n/**\r\n * URL parser.\r\n *\r\n * @param uri - url\r\n * @param path - the request path of the connection\r\n * @param loc - An object meant to mimic window.location.\r\n *        Defaults to window.location.\r\n * @public\r\n */\r\nfunction url(uri, path = \"\", loc) {\r\n    let obj = uri;\r\n    // default to window.location\r\n    loc = loc || (typeof location !== \"undefined\" && location);\r\n    if (null == uri)\r\n        uri = loc.protocol + \"//\" + loc.host;\r\n    // relative path support\r\n    if (typeof uri === \"string\") {\r\n        if (\"/\" === uri.charAt(0)) {\r\n            if (\"/\" === uri.charAt(1)) {\r\n                uri = loc.protocol + uri;\r\n            }\r\n            else {\r\n                uri = loc.host + uri;\r\n            }\r\n        }\r\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\r\n            debug(\"protocol-less url %s\", uri);\r\n            if (\"undefined\" !== typeof loc) {\r\n                uri = loc.protocol + \"//\" + uri;\r\n            }\r\n            else {\r\n                uri = \"https://\" + uri;\r\n            }\r\n        }\r\n        // parse\r\n        debug(\"parse %s\", uri);\r\n        obj = engine_io_client_1.parse(uri);\r\n    }\r\n    // make sure we treat `localhost:80` and `localhost` equally\r\n    if (!obj.port) {\r\n        if (/^(http|ws)$/.test(obj.protocol)) {\r\n            obj.port = \"80\";\r\n        }\r\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\r\n            obj.port = \"443\";\r\n        }\r\n    }\r\n    obj.path = obj.path || \"/\";\r\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\r\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\r\n    // define unique id\r\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\r\n    // define href\r\n    obj.href =\r\n        obj.protocol +\r\n            \"://\" +\r\n            host +\r\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\r\n    return obj;\r\n}\r\nexports.url = url;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/socket.io-client/build/cjs/url.js?");

/***/ }),

/***/ "./node_modules/socket.io-parser/build/cjs/binary.js":
/*!***********************************************************!*\
  !*** ./node_modules/socket.io-parser/build/cjs/binary.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.reconstructPacket = exports.deconstructPacket = void 0;\r\nconst is_binary_js_1 = __webpack_require__(/*! ./is-binary.js */ \"./node_modules/socket.io-parser/build/cjs/is-binary.js\");\r\n/**\r\n * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\r\n *\r\n * @param {Object} packet - socket.io event packet\r\n * @return {Object} with deconstructed packet and list of buffers\r\n * @public\r\n */\r\nfunction deconstructPacket(packet) {\r\n    const buffers = [];\r\n    const packetData = packet.data;\r\n    const pack = packet;\r\n    pack.data = _deconstructPacket(packetData, buffers);\r\n    pack.attachments = buffers.length; // number of binary 'attachments'\r\n    return { packet: pack, buffers: buffers };\r\n}\r\nexports.deconstructPacket = deconstructPacket;\r\nfunction _deconstructPacket(data, buffers) {\r\n    if (!data)\r\n        return data;\r\n    if ((0, is_binary_js_1.isBinary)(data)) {\r\n        const placeholder = { _placeholder: true, num: buffers.length };\r\n        buffers.push(data);\r\n        return placeholder;\r\n    }\r\n    else if (Array.isArray(data)) {\r\n        const newData = new Array(data.length);\r\n        for (let i = 0; i < data.length; i++) {\r\n            newData[i] = _deconstructPacket(data[i], buffers);\r\n        }\r\n        return newData;\r\n    }\r\n    else if (typeof data === \"object\" && !(data instanceof Date)) {\r\n        const newData = {};\r\n        for (const key in data) {\r\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\r\n                newData[key] = _deconstructPacket(data[key], buffers);\r\n            }\r\n        }\r\n        return newData;\r\n    }\r\n    return data;\r\n}\r\n/**\r\n * Reconstructs a binary packet from its placeholder packet and buffers\r\n *\r\n * @param {Object} packet - event packet with placeholders\r\n * @param {Array} buffers - binary buffers to put in placeholder positions\r\n * @return {Object} reconstructed packet\r\n * @public\r\n */\r\nfunction reconstructPacket(packet, buffers) {\r\n    packet.data = _reconstructPacket(packet.data, buffers);\r\n    delete packet.attachments; // no longer useful\r\n    return packet;\r\n}\r\nexports.reconstructPacket = reconstructPacket;\r\nfunction _reconstructPacket(data, buffers) {\r\n    if (!data)\r\n        return data;\r\n    if (data && data._placeholder === true) {\r\n        const isIndexValid = typeof data.num === \"number\" &&\r\n            data.num >= 0 &&\r\n            data.num < buffers.length;\r\n        if (isIndexValid) {\r\n            return buffers[data.num]; // appropriate buffer (should be natural order anyway)\r\n        }\r\n        else {\r\n            throw new Error(\"illegal attachments\");\r\n        }\r\n    }\r\n    else if (Array.isArray(data)) {\r\n        for (let i = 0; i < data.length; i++) {\r\n            data[i] = _reconstructPacket(data[i], buffers);\r\n        }\r\n    }\r\n    else if (typeof data === \"object\") {\r\n        for (const key in data) {\r\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\r\n                data[key] = _reconstructPacket(data[key], buffers);\r\n            }\r\n        }\r\n    }\r\n    return data;\r\n}\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/socket.io-parser/build/cjs/binary.js?");

/***/ }),

/***/ "./node_modules/socket.io-parser/build/cjs/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/socket.io-parser/build/cjs/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;\r\nconst component_emitter_1 = __webpack_require__(/*! @socket.io/component-emitter */ \"./node_modules/@socket.io/component-emitter/index.mjs\");\r\nconst binary_js_1 = __webpack_require__(/*! ./binary.js */ \"./node_modules/socket.io-parser/build/cjs/binary.js\");\r\nconst is_binary_js_1 = __webpack_require__(/*! ./is-binary.js */ \"./node_modules/socket.io-parser/build/cjs/is-binary.js\");\r\nconst debug_1 = __webpack_require__(/*! debug */ \"./node_modules/socket.io-parser/node_modules/debug/src/browser.js\"); // debug()\r\nconst debug = (0, debug_1.default)(\"socket.io-parser\"); // debug()\r\n/**\r\n * These strings must not be used as event names, as they have a special meaning.\r\n */\r\nconst RESERVED_EVENTS = [\r\n    \"connect\",\r\n    \"connect_error\",\r\n    \"disconnect\",\r\n    \"disconnecting\",\r\n    \"newListener\",\r\n    \"removeListener\", // used by the Node.js EventEmitter\r\n];\r\n/**\r\n * Protocol version.\r\n *\r\n * @public\r\n */\r\nexports.protocol = 5;\r\nvar PacketType;\r\n(function (PacketType) {\r\n    PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\r\n    PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\r\n    PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\r\n    PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\r\n    PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\r\n    PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\r\n    PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\r\n})(PacketType = exports.PacketType || (exports.PacketType = {}));\r\n/**\r\n * A socket.io Encoder instance\r\n */\r\nclass Encoder {\r\n    /**\r\n     * Encoder constructor\r\n     *\r\n     * @param {function} replacer - custom replacer to pass down to JSON.parse\r\n     */\r\n    constructor(replacer) {\r\n        this.replacer = replacer;\r\n    }\r\n    /**\r\n     * Encode a packet as a single string if non-binary, or as a\r\n     * buffer sequence, depending on packet type.\r\n     *\r\n     * @param {Object} obj - packet object\r\n     */\r\n    encode(obj) {\r\n        debug(\"encoding packet %j\", obj);\r\n        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\r\n            if ((0, is_binary_js_1.hasBinary)(obj)) {\r\n                return this.encodeAsBinary({\r\n                    type: obj.type === PacketType.EVENT\r\n                        ? PacketType.BINARY_EVENT\r\n                        : PacketType.BINARY_ACK,\r\n                    nsp: obj.nsp,\r\n                    data: obj.data,\r\n                    id: obj.id,\r\n                });\r\n            }\r\n        }\r\n        return [this.encodeAsString(obj)];\r\n    }\r\n    /**\r\n     * Encode packet as string.\r\n     */\r\n    encodeAsString(obj) {\r\n        // first is type\r\n        let str = \"\" + obj.type;\r\n        // attachments if we have them\r\n        if (obj.type === PacketType.BINARY_EVENT ||\r\n            obj.type === PacketType.BINARY_ACK) {\r\n            str += obj.attachments + \"-\";\r\n        }\r\n        // if we have a namespace other than `/`\r\n        // we append it followed by a comma `,`\r\n        if (obj.nsp && \"/\" !== obj.nsp) {\r\n            str += obj.nsp + \",\";\r\n        }\r\n        // immediately followed by the id\r\n        if (null != obj.id) {\r\n            str += obj.id;\r\n        }\r\n        // json data\r\n        if (null != obj.data) {\r\n            str += JSON.stringify(obj.data, this.replacer);\r\n        }\r\n        debug(\"encoded %j as %s\", obj, str);\r\n        return str;\r\n    }\r\n    /**\r\n     * Encode packet as 'buffer sequence' by removing blobs, and\r\n     * deconstructing packet into object with placeholders and\r\n     * a list of buffers.\r\n     */\r\n    encodeAsBinary(obj) {\r\n        const deconstruction = (0, binary_js_1.deconstructPacket)(obj);\r\n        const pack = this.encodeAsString(deconstruction.packet);\r\n        const buffers = deconstruction.buffers;\r\n        buffers.unshift(pack); // add packet info to beginning of data list\r\n        return buffers; // write all the buffers\r\n    }\r\n}\r\nexports.Encoder = Encoder;\r\n// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript\r\nfunction isObject(value) {\r\n    return Object.prototype.toString.call(value) === \"[object Object]\";\r\n}\r\n/**\r\n * A socket.io Decoder instance\r\n *\r\n * @return {Object} decoder\r\n */\r\nclass Decoder extends component_emitter_1.Emitter {\r\n    /**\r\n     * Decoder constructor\r\n     *\r\n     * @param {function} reviver - custom reviver to pass down to JSON.stringify\r\n     */\r\n    constructor(reviver) {\r\n        super();\r\n        this.reviver = reviver;\r\n    }\r\n    /**\r\n     * Decodes an encoded packet string into packet JSON.\r\n     *\r\n     * @param {String} obj - encoded packet\r\n     */\r\n    add(obj) {\r\n        let packet;\r\n        if (typeof obj === \"string\") {\r\n            if (this.reconstructor) {\r\n                throw new Error(\"got plaintext data when reconstructing a packet\");\r\n            }\r\n            packet = this.decodeString(obj);\r\n            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;\r\n            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {\r\n                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;\r\n                // binary packet's json\r\n                this.reconstructor = new BinaryReconstructor(packet);\r\n                // no attachments, labeled binary but no binary data to follow\r\n                if (packet.attachments === 0) {\r\n                    super.emitReserved(\"decoded\", packet);\r\n                }\r\n            }\r\n            else {\r\n                // non-binary full packet\r\n                super.emitReserved(\"decoded\", packet);\r\n            }\r\n        }\r\n        else if ((0, is_binary_js_1.isBinary)(obj) || obj.base64) {\r\n            // raw binary data\r\n            if (!this.reconstructor) {\r\n                throw new Error(\"got binary data when not reconstructing a packet\");\r\n            }\r\n            else {\r\n                packet = this.reconstructor.takeBinaryData(obj);\r\n                if (packet) {\r\n                    // received final buffer\r\n                    this.reconstructor = null;\r\n                    super.emitReserved(\"decoded\", packet);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(\"Unknown type: \" + obj);\r\n        }\r\n    }\r\n    /**\r\n     * Decode a packet String (JSON data)\r\n     *\r\n     * @param {String} str\r\n     * @return {Object} packet\r\n     */\r\n    decodeString(str) {\r\n        let i = 0;\r\n        // look up type\r\n        const p = {\r\n            type: Number(str.charAt(0)),\r\n        };\r\n        if (PacketType[p.type] === undefined) {\r\n            throw new Error(\"unknown packet type \" + p.type);\r\n        }\r\n        // look up attachments if type binary\r\n        if (p.type === PacketType.BINARY_EVENT ||\r\n            p.type === PacketType.BINARY_ACK) {\r\n            const start = i + 1;\r\n            while (str.charAt(++i) !== \"-\" && i != str.length) { }\r\n            const buf = str.substring(start, i);\r\n            if (buf != Number(buf) || str.charAt(i) !== \"-\") {\r\n                throw new Error(\"Illegal attachments\");\r\n            }\r\n            p.attachments = Number(buf);\r\n        }\r\n        // look up namespace (if any)\r\n        if (\"/\" === str.charAt(i + 1)) {\r\n            const start = i + 1;\r\n            while (++i) {\r\n                const c = str.charAt(i);\r\n                if (\",\" === c)\r\n                    break;\r\n                if (i === str.length)\r\n                    break;\r\n            }\r\n            p.nsp = str.substring(start, i);\r\n        }\r\n        else {\r\n            p.nsp = \"/\";\r\n        }\r\n        // look up id\r\n        const next = str.charAt(i + 1);\r\n        if (\"\" !== next && Number(next) == next) {\r\n            const start = i + 1;\r\n            while (++i) {\r\n                const c = str.charAt(i);\r\n                if (null == c || Number(c) != c) {\r\n                    --i;\r\n                    break;\r\n                }\r\n                if (i === str.length)\r\n                    break;\r\n            }\r\n            p.id = Number(str.substring(start, i + 1));\r\n        }\r\n        // look up json data\r\n        if (str.charAt(++i)) {\r\n            const payload = this.tryParse(str.substr(i));\r\n            if (Decoder.isPayloadValid(p.type, payload)) {\r\n                p.data = payload;\r\n            }\r\n            else {\r\n                throw new Error(\"invalid payload\");\r\n            }\r\n        }\r\n        debug(\"decoded %s as %j\", str, p);\r\n        return p;\r\n    }\r\n    tryParse(str) {\r\n        try {\r\n            return JSON.parse(str, this.reviver);\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n    static isPayloadValid(type, payload) {\r\n        switch (type) {\r\n            case PacketType.CONNECT:\r\n                return isObject(payload);\r\n            case PacketType.DISCONNECT:\r\n                return payload === undefined;\r\n            case PacketType.CONNECT_ERROR:\r\n                return typeof payload === \"string\" || isObject(payload);\r\n            case PacketType.EVENT:\r\n            case PacketType.BINARY_EVENT:\r\n                return (Array.isArray(payload) &&\r\n                    (typeof payload[0] === \"number\" ||\r\n                        (typeof payload[0] === \"string\" &&\r\n                            RESERVED_EVENTS.indexOf(payload[0]) === -1)));\r\n            case PacketType.ACK:\r\n            case PacketType.BINARY_ACK:\r\n                return Array.isArray(payload);\r\n        }\r\n    }\r\n    /**\r\n     * Deallocates a parser's resources\r\n     */\r\n    destroy() {\r\n        if (this.reconstructor) {\r\n            this.reconstructor.finishedReconstruction();\r\n            this.reconstructor = null;\r\n        }\r\n    }\r\n}\r\nexports.Decoder = Decoder;\r\n/**\r\n * A manager of a binary event's 'buffer sequence'. Should\r\n * be constructed whenever a packet of type BINARY_EVENT is\r\n * decoded.\r\n *\r\n * @param {Object} packet\r\n * @return {BinaryReconstructor} initialized reconstructor\r\n */\r\nclass BinaryReconstructor {\r\n    constructor(packet) {\r\n        this.packet = packet;\r\n        this.buffers = [];\r\n        this.reconPack = packet;\r\n    }\r\n    /**\r\n     * Method to be called when binary data received from connection\r\n     * after a BINARY_EVENT packet.\r\n     *\r\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\r\n     * @return {null | Object} returns null if more binary data is expected or\r\n     *   a reconstructed packet object if all buffers have been received.\r\n     */\r\n    takeBinaryData(binData) {\r\n        this.buffers.push(binData);\r\n        if (this.buffers.length === this.reconPack.attachments) {\r\n            // done with buffer list\r\n            const packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);\r\n            this.finishedReconstruction();\r\n            return packet;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Cleans up binary packet reconstruction variables.\r\n     */\r\n    finishedReconstruction() {\r\n        this.reconPack = null;\r\n        this.buffers = [];\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/socket.io-parser/build/cjs/index.js?");

/***/ }),

/***/ "./node_modules/socket.io-parser/build/cjs/is-binary.js":
/*!**************************************************************!*\
  !*** ./node_modules/socket.io-parser/build/cjs/is-binary.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.hasBinary = exports.isBinary = void 0;\r\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\r\nconst isView = (obj) => {\r\n    return typeof ArrayBuffer.isView === \"function\"\r\n        ? ArrayBuffer.isView(obj)\r\n        : obj.buffer instanceof ArrayBuffer;\r\n};\r\nconst toString = Object.prototype.toString;\r\nconst withNativeBlob = typeof Blob === \"function\" ||\r\n    (typeof Blob !== \"undefined\" &&\r\n        toString.call(Blob) === \"[object BlobConstructor]\");\r\nconst withNativeFile = typeof File === \"function\" ||\r\n    (typeof File !== \"undefined\" &&\r\n        toString.call(File) === \"[object FileConstructor]\");\r\n/**\r\n * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\r\n *\r\n * @private\r\n */\r\nfunction isBinary(obj) {\r\n    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||\r\n        (withNativeBlob && obj instanceof Blob) ||\r\n        (withNativeFile && obj instanceof File));\r\n}\r\nexports.isBinary = isBinary;\r\nfunction hasBinary(obj, toJSON) {\r\n    if (!obj || typeof obj !== \"object\") {\r\n        return false;\r\n    }\r\n    if (Array.isArray(obj)) {\r\n        for (let i = 0, l = obj.length; i < l; i++) {\r\n            if (hasBinary(obj[i])) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    if (isBinary(obj)) {\r\n        return true;\r\n    }\r\n    if (obj.toJSON &&\r\n        typeof obj.toJSON === \"function\" &&\r\n        arguments.length === 1) {\r\n        return hasBinary(obj.toJSON(), true);\r\n    }\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.hasBinary = hasBinary;\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/socket.io-parser/build/cjs/is-binary.js?");

/***/ }),

/***/ "./node_modules/@socket.io/component-emitter/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@socket.io/component-emitter/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Emitter: () => (/* binding */ Emitter)\n/* harmony export */ });\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n}\r\n\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks['$' + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks['$' + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i < callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Remove event specific arrays for event types that no\r\n  // one is subscribed for to avoid memory leak.\r\n  if (callbacks.length === 0) {\r\n    delete this._callbacks['$' + event];\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  var args = new Array(arguments.length - 1)\r\n    , callbacks = this._callbacks['$' + event];\r\n\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    args[i - 1] = arguments[i];\r\n  }\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n// alias used for reserved events (protected method)\r\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks['$' + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\r\n\n\n//# sourceURL=webpack://watermelon-io/./node_modules/@socket.io/component-emitter/index.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./server/public/titlescene/index.ts");
/******/ 	
/******/ })()
;